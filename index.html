<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë²™ì»¤ ë””íœìŠ¤</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            /* (ìˆ˜ì •) ë†’ì´ì™€ ë„ˆë¹„ë¥¼ 100%ë¡œ ì„¤ì •í•˜ì—¬ ë·°í¬íŠ¸ ì „ì²´ë¥¼ ì‚¬ìš© */
            height: 100%; 
            width: 100%;
            margin: 0;
            overflow: hidden;
            /* (ì¶”ê°€) body ìì²´ë¥¼ ë·°í¬íŠ¸ì— ê³ ì • */
            position: fixed; 
            top: 0;
            left: 0;
        }
        #game-container {
            position: relative;
            /* (ìˆ˜ì •) ë·°í¬íŠ¸ì— ê½‰ ì°¨ë„ë¡ 100% ì‚¬ìš© */
            width: 100%;
            height: 100%;
            pointer-events: none;
        }

        /* (ì¶”ê°€) ìº”ë²„ìŠ¤ë¥¼ ë°°ê²½ì— ê½‰ ì±„ì›ë‹ˆë‹¤ */
        #game-canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1; /* ìº”ë²„ìŠ¤ë¥¼ ë§¨ ë’¤ë¡œ */
        }
        
        /* (ì¶”ê°€) UI ì»¨í…Œì´ë„ˆë¥¼ ìº”ë²„ìŠ¤ ìœ„ì— ë„ì›ë‹ˆë‹¤ */
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none; /* ìì‹(top/bottom-ui)ì—ì„œ autoë¡œ ì¬ì„¤ì •ë¨ */
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            z-index: 12; /* (ìˆ˜ì •) UIë¥¼ ìº”ë²„ìŠ¤ ìœ„ë¡œ, ì˜¤ë²„ë ˆì´(10)ë³´ë‹¤ ë†’ê²Œ ì„¤ì • */
        }

        #top-ui, #bottom-ui {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: auto; /* (ìˆ˜ì •) í•˜ìœ„ ìš”ì†Œê°€ í´ë¦­ë˜ë„ë¡ ì¬ì„¤ì • */
            position: relative; /* (ì¶”ê°€) z-indexë¥¼ ì ìš©í•˜ê¸° ìœ„í•´ position ì„¤ì • */
            z-index: 11; /* (ì¶”ê°€) ì˜¤ë²„ë ˆì´(z-index: 10)ë³´ë‹¤ ìœ„ì— ì˜¤ë„ë¡ ì„¤ì • */
        }
        #top-ui {
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
         #bottom-ui {
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }
        #bunker-hp-bar {
            width: 100%;
            height: 20px;
            background-color: #555;
            border: 1px solid #777;
            border-radius: 10px;
            overflow: hidden;
        }
        #bunker-hp-fill {
            width: 100%;
            height: 100%;
            background-color: #4CAF50; /* ë…¹ìƒ‰ */
            transition: width 0.3s ease;
        }
        #xp-bar {
            width: 100%;
            height: 10px;
            background-color: #555;
            border: 1px solid #777;
            border-radius: 5px;
            overflow: hidden;
        }
        #xp-fill {
            width: 0%;
            height: 100%;
            background-color: #3498db; /* íŒŒë€ìƒ‰ */
            transition: width 0.3s ease;
        }
        #stats {
            display: flex;
            gap: 20px;
            font-size: 1.1em;
            font-weight: bold;
        }
        #level-text, #kill-count, #timer {
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        /* ë³´ìœ  ìœ ë‹› í‘œì‹œ */
        #unit-display {
            display: flex;
            gap: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
        }
        #unit-display span {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        /* ì˜¤ë””ì˜¤ ì„¤ì • ë²„íŠ¼ */
        #settings-ui {
            display: flex;
            gap: 10px;
        }
        .setting-btn {
            font-family: inherit;
            font-size: 0.9em;
            font-weight: bold;
            padding: 5px 10px;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            background-color: #555;
            transition: background-color 0.2s;
            min-width: 80px; /* ë²„íŠ¼ í¬ê¸° ê³ ì • */
            text-align: center;
        }
        .setting-btn:hover {
            background-color: #777;
        }
        .setting-btn.off {
            background-color: #e74c3c; /* ë¹¨ê°„ìƒ‰ (Off ìƒíƒœ) */
        }
        
        /* ìŠ¤í‚¬ íŒ¨ë„ ìŠ¤íƒ€ì¼ */
        #skill-panel {
            display: flex;
            gap: 10px;
            margin-top: 10px;
        }

        .skill-btn {
            font-family: inherit;
            font-size: 1.1em;
            font-weight: bold;
            padding: 8px 15px;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            background-color: #3b82f6; /* íŒŒë€ìƒ‰ ê³„ì—´ */
            transition: all 0.2s;
            position: relative;
            min-width: 100px;
        }

        .skill-btn:disabled {
            cursor: not-allowed;
            background-color: #777;
            opacity: 0.8;
            color: #bbb;
        }
        
        .skill-cooldown {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 1.5em;
            font-weight: bold;
            border-radius: 8px;
        }


        /* ëª¬ìŠ¤í„° ì •ë³´ í‘œì‹œ */
        #monster-info {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #ddd;
            padding-bottom: 5px;
        }

        /* ì˜¤ë²„ë ˆì´ (ì‹œì‘, ë ˆë²¨ì—…, ê²Œì„ì˜¤ë²„) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: auto;
            z-index: 10;
        }
        .overlay h1 {
            font-size: 3em;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 3px 3px 5px rgba(0,0,0,0.7);
        }
        .overlay p {
            font-size: 1.2em;
            color: #ddd;
            margin-bottom: 30px;
        }

        /* ë‚œì´ë„ ë²„íŠ¼ */
        #difficulty-select {
            display: flex;
            flex-direction: column;
            gap: 15px;
            /* (ìˆ˜ì •) ëª¨ë°”ì¼ì— ìœ ì—°í•˜ê²Œ ë§ë„ë¡ max-widthì™€ widthë¥¼ vw ê¸°ì¤€ìœ¼ë¡œ ì„¤ì • */
            width: 80vw;
            max-width: 300px;
        }
        .diff-button {
            font-family: inherit;
            font-size: 1.3em;
            font-weight: bold;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }
        .diff-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        #diff-1 { background-color: #4CAF50; } /* ì•„ì£¼ ì‰¬ì›€ */
        #diff-1:hover { background-color: #45a049; }
        #diff-2 { background-color: #3498db; } /* ì‰¬ì›€ */
        #diff-2:hover { background-color: #2980b9; }
        #diff-3 { background-color: #7f8c8d; } /* ë³´í†µ */
        #diff-3:hover { background-color: #717d7e; }
        #diff-4 { background-color: #f1c40f; } /* ì¡°ê¸ˆ ì–´ë ¤ì›€ */
        #diff-4:hover { background-color: #f39c12; }
        #diff-5 { background-color: #e74c3c; } /* ë§¤ìš° ì–´ë ¤ì›€ */
        #diff-5:hover { background-color: #c0392b; }


        #upgrade-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 80%;
            max-width: 400px;
        }
        .upgrade-option {
            background: #444;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #555;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        .upgrade-option:hover {
            background: #555;
            border-color: #777;
            transform: translateY(-3px);
        }
        .upgrade-option h3 {
            margin: 0 0 5px 0;
            color: #3498db; /* íŒŒë€ìƒ‰ */
        }
        .upgrade-option p {
            margin: 0;
            color: #ccc;
            font-size: 0.9em;
        }

        #permanent-shop-overlay {
            display: none;
            /* ë ˆë²¨ì—… ì˜¤ë²„ë ˆì´ì™€ ë™ì¼í•œ ìŠ¤íƒ€ì¼ì„ ì‚¬ìš© */
        }

        /* (ì¶”ê°€/ìˆ˜ì •) ì˜êµ¬ ìƒì ì˜ Grid ë ˆì´ì•„ì›ƒ */
        #permanent-upgrade-container { 
            display: grid; 
            grid-template-columns: repeat(2, 1fr); /* 2ì—´ ê·¸ë¦¬ë“œ */
            gap: 15px;
            width: 90%; 
            max-width: 800px; 
            margin-top: 20px;
            padding: 0 10px; /* ì¢Œìš° íŒ¨ë”© ì¶”ê°€ */
        }

        #game-over-overlay {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
        }
        
        #start-overlay {
            display: none; /* ë°ì´í„° ë¡œë“œ ì™„ë£Œ í›„ í‘œì‹œë¨ */
        }

        #loading-overlay {
            display: flex; /* ë¡œë”© ì¤‘ í‘œì‹œ */
        }


        #level-up-overlay {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
        }

        /* (ì¶”ê°€) ì¼ì‹œì •ì§€ ì˜¤ë²„ë ˆì´ */
        #pause-overlay {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
        }

        /* --- ëª¨ë°”ì¼ ë°˜ì‘í˜• CSS (í™”ë©´ ë„ˆë¹„ 600px ì´í•˜) --- */
        @media (max-width: 600px) {
            #top-ui, #bottom-ui {
                padding: 8px 10px;
                font-size: 0.9em;
            }

            #stats {
                gap: 5px; /* ê°„ê²© ì¶•ì†Œ */
                font-size: 0.8em;
            }

            #unit-display {
                gap: 5px; /* ê°„ê²© ì¶•ì†Œ */
                font-size: 0.8em;
            }

            #settings-ui {
                gap: 5px; /* ê°„ê²© ì¶•ì†Œ */
            }

            .setting-btn {
                min-width: 50px; /* ë²„íŠ¼ ìµœì†Œ ë„ˆë¹„ ì¶•ì†Œ */
                padding: 4px 6px;
                font-size: 0.75em;
            }
            
            /* ìŠ¤í‚¬ íŒ¨ë„ ì¡°ì • */
            #skill-panel {
                gap: 5px;
                margin-top: 5px;
            }
            .skill-btn {
                font-size: 0.8em;
                padding: 6px 10px;
                min-width: 80px;
            }
            .skill-cooldown {
                font-size: 1.2em; /* ì¿¨íƒ€ì„ ìˆ«ì í¬ê¸° ìœ ì§€ */
            }

            /* ìƒì  UI ëª¨ë°”ì¼ ìµœì í™” (1ì—´ë¡œ ë³€ê²½) */
            #permanent-upgrade-container { 
                grid-template-columns: 1fr; /* 1ì—´ ê·¸ë¦¬ë“œ */
                gap: 10px;
                width: 95%; 
            }
            .upgrade-option {
                padding: 15px;
            }
            .upgrade-option h3 {
                font-size: 1em;
            }
            
            /* (ì¶”ê°€) ë‚œì´ë„ ì˜¤ë²„ë ˆì´ ëª¨ë°”ì¼ ìµœì í™” */
            #difficulty-select {
                width: 90vw; /* ë·°í¬íŠ¸ ë„ˆë¹„ì— ë§ê²Œ ì¡°ì • */
            }
            .diff-button {
                font-size: 1.1em;
                padding: 12px 15px;
            }
            .overlay h1 {
                 font-size: 2em; /* ì˜¤ë²„ë ˆì´ í—¤ë” í¬ê¸° ì¶•ì†Œ */
            }
            .overlay p {
                 font-size: 1em; /* ì˜¤ë²„ë ˆì´ í…ìŠ¤íŠ¸ í¬ê¸° ì¶•ì†Œ */
            }
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <div id="top-ui">
                <div id="stats">
                    <span id="money-display">ğŸ’° LOADING...</span> <!-- (ì¶”ê°€) ë¨¸ë‹ˆ í‘œì‹œ -->
                    <span id="level-text">LV. 1</span>
                    <span id="kill-count">Kills: 0</span>
                    <span id="timer">00:00</span>
                </div>
                <!-- ë³´ìœ  ìœ ë‹› í‘œì‹œ UI -->
                <div id="unit-display">
                    <span id="marine-count">ğŸ§‘â€ğŸš€ 0</span>
                    <span id="firebat-count">ğŸ”¥ 0</span>
                    <span id="tank-count">ğŸ›¡ï¸ 0</span>
                    <span id="ghost-count">ğŸ‘» 0</span>
                </div>
                <!-- ì˜¤ë””ì˜¤ ì„¤ì • UI -->
                <div id="settings-ui">
                    <button id="permanent-shop-btn" class="setting-btn">ìƒì  ğŸ›’</button> <!-- (ì¶”ê°€) ìƒì  ë²„íŠ¼ -->
                    <button id="bgm-toggle" class="setting-btn">BGM: ğŸµ</button>
                    <button id="sfx-toggle" class="setting-btn">SFX: ğŸ”Š</button>
                    <!-- (ì¶”ê°€) ì¼ì‹œì •ì§€ ë²„íŠ¼ -->
                    <button id="pause-toggle" class="setting-btn">PAUSE â¸ï¸</button>
                </div>
            </div>
            <div id="bottom-ui">
                 <!-- (ì´ë™) ìŠ¤í‚¬ íŒ¨ë„ì„ ë§¨ ìœ„ë¡œ ì˜¬ë¦¼ -->
                <div id="skill-panel">
                    <button id="skill-irradiate" class="skill-btn" disabled>
                        ì´ë ˆë””ì—ì‡ (300)
                        <span id="skill-irradiate-cooldown" class="skill-cooldown" style="display:none;"></span>
                    </button>
                    <button id="skill-defmatrix" class="skill-btn" disabled>
                        ë°©ì–´ ë§¤íŠ¸ë¦­ìŠ¤ (200)
                        <span id="skill-defmatrix-cooldown" class="skill-cooldown" style="display:none;"></span>
                    </button>
                    <!-- AI ë²„íŠ¼ ì œê±° -->
                </div>
                <!-- ëª¬ìŠ¤í„° ì •ë³´ UI -->
                <div id="monster-info">ë“±ì¥: ğŸ›</div>
                <div id="bunker-hp-bar">
                    <div id="bunker-hp-fill"></div>
                </div>
                <div id="xp-bar">
                    <div id="xp-fill"></div>
                </div>
            </div>
        </div>

        <!-- ë¡œë”© ì˜¤ë²„ë ˆì´ (ë°ì´í„°ë² ì´ìŠ¤ ë¡œë“œ ëŒ€ê¸°) -->
        <div id="loading-overlay" class="overlay">
            <h1>ë°ì´í„° ë¡œë“œ ì¤‘...</h1>
            <p>ì ì‹œë§Œ ê¸°ë‹¤ë ¤ì£¼ì„¸ìš”.</p>
        </div>


        <!-- ê²Œì„ ì‹œì‘ ì˜¤ë²„ë ˆì´ -->
        <div id="start-overlay" class="overlay">
            <h1>ê¸°ì§€ ë°©ì–´</h1>
            <p>ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
            <!-- ë‚œì´ë„ ì„ íƒ ë²„íŠ¼ (ë°°ìœ¨ ìˆ˜ì •) -->
            <div id="difficulty-select">
                <button id="diff-1" class="diff-button" data-diff="0.6">ì•„ì£¼ ì‰¬ì›€</button>
                <button id="diff-2" class="diff-button" data-diff="0.8">ì‰¬ì›€</button>
                <button id="diff-3" class="diff-button" data-diff="1.2">ë³´í†µ</button>
                <button id="diff-4" class="diff-button" data-diff="1.8">ì¡°ê¸ˆ ì–´ë ¤ì›€</button>
                <button id="diff-5" class="diff-button" data-diff="2.5">ë§¤ìš° ì–´ë ¤ì›€</button>
            </div>
        </div>

        <!-- ë ˆë²¨ì—… ì˜¤ë²„ë ˆì´ -->
        <div id="level-up-overlay" class="overlay">
            <h1>ë ˆë²¨ ì—…!</h1>
            <p>ì—…ê·¸ë ˆì´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
            <div id="upgrade-container">
                <!-- ì—…ê·¸ë ˆì´ë“œ ì˜µì…˜ì´ ë™ì ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. -->
            </div>
        </div>

         <!-- (ì¶”ê°€) ì˜êµ¬ ìƒì  ì˜¤ë²„ë ˆì´ -->
         <div id="permanent-shop-overlay" class="overlay">
            <h1>ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ìƒì </h1>
            <p id="shop-money-info">í˜„ì¬ ìê¸ˆ: ğŸ’° 0</p>
            <div id="permanent-upgrade-container" class="upgrade-container">
                <!-- ìƒì  í•­ëª©ì´ ë™ì ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. -->
            </div>
            <button id="close-shop-btn" class="diff-button" style="background-color: #555; margin-top: 20px;">ë‹«ê¸°</button>
        </div>


        <!-- ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ -->
        <div id="game-over-overlay" class="overlay">
            <h1>ê²Œì„ ì˜¤ë²„</h1>
            <p id="game-over-stats">ìµœì¢… ìƒì¡´ ì‹œê°„: 00:00 | ìµœì¢… í‚¬ ìˆ˜: 0</p>
            <button id="restart-button" class="diff-button" style="background-color: #4CAF50;">ë‹¤ì‹œ ì‹œì‘</button>
        </div>

        <!-- (ì¶”ê°€) ì¼ì‹œì •ì§€ ì˜¤ë²„ë ˆì´ -->
        <div id="pause-overlay" class="overlay">
            <h1>PAUSED</h1>
            <p>ê²Œì„ì´ ì¼ì‹œì •ì§€ë˜ì—ˆìŠµë‹ˆë‹¤.</p>
        </div>
        
    </div>

    <script type="module">
        // --- Firebase/Firestore ëª¨ë“ˆ ì„í¬íŠ¸ (ë°ì´í„°ë² ì´ìŠ¤ ì—°ë™) ---
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // setLogLevel('debug'); // Firestore ë””ë²„ê·¸ ë¡œê¹… í™œì„±í™” (í•„ìš” ì‹œ ì£¼ì„ í•´ì œ)

        // Global variables (Mandatory to use)
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        let db;
        let auth;
        let userId = 'loading'; // ì´ˆê¸° ì‚¬ìš©ì ID ìƒíƒœ

        // ì˜êµ¬ ì‚¬ìš©ì ë°ì´í„° ìƒíƒœ
        let userData = {
            money: 0,
            baseDamageLevel: 0, // ê¸°ë³¸ ë°ë¯¸ì§€ ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ë ˆë²¨ (0ë¶€í„° ì‹œì‘)
            baseHPLevel: 0,     // ê¸°ë³¸ HP ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ë ˆë²¨ (0ë¶€í„° ì‹œì‘)
            baseRegenLevel: 0,  // (ì¶”ê°€) ê¸°ì§€ ì¬ìƒ ì†ë„ ë ˆë²¨
            initialMoneyLevel: 0, // (ì¶”ê°€) ì‹œì‘ ìê¸ˆ ë ˆë²¨
            // (ì¶”ê°€) ìŠ¤í‚¬ êµ¬ë§¤ ìƒíƒœ
            irradiateLevel: 0, // (ìˆ˜ì •) ì´ë ˆë””ì—ì‡ ë ˆë²¨ (ìµœëŒ€ 3)
            defensiveMatrixLevel: 0, // (ìˆ˜ì •) ë””íœì‹œë¸Œ ë§¤íŠ¸ë¦­ìŠ¤ ë ˆë²¨ (ìµœëŒ€ 3)
        };

        // ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ì •ì˜
        const permanentUpgrades = {
            baseDamage: { 
                title: "ê¸°ë³¸ ë°ë¯¸ì§€ ê°•í™”", 
                costBase: 100, 
                costMultiplier: 1.5,
                effectPerLevel: 1.5, // ë ˆë²¨ë‹¹ ê¸°ë³¸ ë°ë¯¸ì§€ +1.5 ì¦ê°€
                maxLevel: 10
            },
            baseHP: { 
                title: "ê¸°ì§€ ë‚´êµ¬ë„ ê°•í™”", 
                costBase: 150, 
                costMultiplier: 1.6,
                effectPerLevel: 25, // ë ˆë²¨ë‹¹ ìµœëŒ€ HP +25 ì¦ê°€
                maxLevel: 10
            },
            // (ì¶”ê°€) ê¸°ì§€ ì¬ìƒ ì†ë„ ì—…ê·¸ë ˆì´ë“œ
             baseRegen: {
                title: "ê¸°ì§€ ì¬ìƒ ì†ë„",
                costBase: 120,
                costMultiplier: 1.4,
                effectPerLevel: 0.1, // ë ˆë²¨ë‹¹ ì´ˆë‹¹ HP ì¬ìƒ +0.1 ì¦ê°€
                maxLevel: 15
            },
            // (ì¶”ê°€) ì‹œì‘ ìê¸ˆ ì—…ê·¸ë ˆì´ë“œ
            initialMoney: {
                title: "ì‹œì‘ ìê¸ˆ ì¦ê°€",
                costBase: 200,
                costMultiplier: 1.8,
                effectPerLevel: 50, // ë ˆë²¨ë‹¹ ì‹œì‘ ìê¸ˆ +50 ì¦ê°€
                maxLevel: 5
            },
            // (ì¶”ê°€) ìŠ¤í‚¬ êµ¬ë§¤/ë ˆë²¨ì—… ì—…ê·¸ë ˆì´ë“œ
            buyIrradiate: {
                title: "ìŠ¤í‚¬: ì´ë ˆë””ì—ì‡",
                costBase: 1000, // (ìˆ˜ì •) ê°€ê²© 1000
                costMultiplier: 1.5, // (ìˆ˜ì •) ë ˆë²¨ë‹¹ 1.5ë°° ì¦ê°€
                effectPerLevel: 0, // (ìˆ˜ì •) ëª…ì‹œì ìœ¼ë¡œ 0 ì„¤ì •
                maxLevel: 3, // (ìˆ˜ì •) ìµœëŒ€ 3ë ˆë²¨
            },
            buyDefensiveMatrix: {
                title: "ìŠ¤í‚¬: ë°©ì–´ ë§¤íŠ¸ë¦­ìŠ¤",
                costBase: 800, // (ìˆ˜ì •) ê°€ê²© 800
                costMultiplier: 1.5, // (ìˆ˜ì •) ë ˆë²¨ë‹¹ 1.5ë°° ì¦ê°€
                effectPerLevel: 0, // (ìˆ˜ì •) ëª…ì‹œì ìœ¼ë¡œ 0 ì„¤ì •
                maxLevel: 3, // (ìˆ˜ì •) ìµœëŒ€ 3ë ˆë²¨
            }
        };

        // ì•¡í‹°ë¸Œ ìŠ¤í‚¬ ë°ì´í„° (ë ˆë²¨ë³„ íš¨ê³¼ ê³„ì‚°ì„ ìœ„í•œ ê¸°ë³¸ê°’)
        const SKILL_DATA_BASE = {
            irradiate: {
                cooldown: 50000, // ê¸°ë³¸ 50s
                duration: 5000, // ê¸°ë³¸ 5s
                dotDamage: 2,
                radius: 400, 
                emoji: 'â˜¢ï¸', 
                cooldownDecreasePerLevel: 5000, // ë ˆë²¨ë‹¹ 5ì´ˆ ê°ì†Œ
                durationIncreasePerLevel: 1000 // ë ˆë²¨ë‹¹ 1ì´ˆ ì¦ê°€
            },
            defensivematrix: { // (ìˆ˜ì •) defensiveMatrix -> defensivematrix ë¡œ ì†Œë¬¸ì í†µì¼
                cooldown: 70000, // ê¸°ë³¸ 70s
                duration: 8000, // ê¸°ë³¸ 8s
                damageCap: 1, 
                emoji: 'ğŸŒ',
                cooldownDecreasePerLevel: 5000, // ë ˆë²¨ë‹¹ 5ì´ˆ ê°ì†Œ
                durationIncreasePerLevel: 2000 // ë ˆë²¨ë‹¹ 2ì´ˆ ì¦ê°€
            }
        };
        
        // ìŠ¤í‚¬ ë°ì´í„° (ì‹¤ì œ ê²Œì„ì—ì„œ ì‚¬ìš©ë , ë ˆë²¨ì´ ì ìš©ëœ ê°’)
        let SKILL_DATA = {}; 
        
        // ìŠ¤í‚¬ ë ˆë²¨ì— ë”°ë¥¸ íš¨ê³¼ ê³„ì‚° í•¨ìˆ˜ (ì´ˆê¸° ë¡œë“œ ì‹œ ë° ì—…ê·¸ë ˆì´ë“œ ì‹œ í˜¸ì¶œ)
        function calculateSkillStats() {
            // ì´ë ˆë””ì—ì‡
            const iLvl = userData.irradiateLevel;
            SKILL_DATA.irradiate = {
                ...SKILL_DATA_BASE.irradiate,
                cooldown: Math.max(10000, SKILL_DATA_BASE.irradiate.cooldown - (iLvl * SKILL_DATA_BASE.irradiate.cooldownDecreasePerLevel)),
                duration: SKILL_DATA_BASE.irradiate.duration + (iLvl * SKILL_DATA_BASE.irradiate.durationIncreasePerLevel),
                cost: permanentUpgrades.buyIrradiate.costBase // ìƒì  UIìš©
            };
            
            // ë””íœì‹œë¸Œ ë§¤íŠ¸ë¦­ìŠ¤
            const dLvl = userData.defensiveMatrixLevel;
            SKILL_DATA.defensivematrix = {
                ...SKILL_DATA_BASE.defensivematrix, // (ìˆ˜ì •) ì†Œë¬¸ì í‚¤ë¡œ ì°¸ì¡°
                cooldown: Math.max(10000, SKILL_DATA_BASE.defensivematrix.cooldown - (dLvl * SKILL_DATA_BASE.defensivematrix.cooldownDecreasePerLevel)), // (ìˆ˜ì •) ì†Œë¬¸ì í‚¤ë¡œ ì°¸ì¡°
                duration: SKILL_DATA_BASE.defensivematrix.duration + (dLvl * SKILL_DATA_BASE.defensivematrix.durationIncreasePerLevel), // (ìˆ˜ì •) ì†Œë¬¸ì í‚¤ë¡œ ì°¸ì¡°
                cost: permanentUpgrades.buyDefensiveMatrix.costBase // ìƒì  UIìš©
            };
            
            // ìŠ¤í‚¬ ë²„íŠ¼ í…ìŠ¤íŠ¸ ì—…ë°ì´íŠ¸
            ui.skillIrradiate.textContent = `ì´ë ˆë””ì—ì‡ (${Math.ceil(SKILL_DATA.irradiate.cooldown / 1000)}s)`;
            ui.skillDefMatrix.textContent = `ë°©ì–´ ë§¤íŠ¸ë¦­ìŠ¤ (${Math.ceil(SKILL_DATA.defensivematrix.cooldown / 1000)}s)`;

            console.log("Skill Stats Recalculated:", SKILL_DATA);
        }
        
        // Firebase ì´ˆê¸°í™” ë° ì¸ì¦
        async function initFirebase() {
            try {
                const app = initializeApp(firebaseConfig);
                auth = getAuth(app);
                db = getFirestore(app);

                // Custom Token ì¸ì¦ ë˜ëŠ” ìµëª… ì¸ì¦
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }
                
                // ì¸ì¦ëœ ì‚¬ìš©ì ID ì„¤ì •
                userId = auth.currentUser.uid;
                console.log("Firebase Auth Success. User ID:", userId);
                
                // ë°ì´í„° ë¡œë“œ
                await loadUserData();
                
            } catch (error) {
                console.error("Firebase ì´ˆê¸°í™” ë˜ëŠ” ì¸ì¦ ì‹¤íŒ¨:", error);
                // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ìœ¼ë¡œ ì§„í–‰
                userId = 'guest'; 
                calculateSkillStats(); // ìŠ¤í‚¬ ê³„ì‚° (ê¸°ë³¸ ë ˆë²¨ 0)
                updateMoneyDisplay();
            }
        }

        // Firestoreì—ì„œ ì‚¬ìš©ì ë°ì´í„° ë¡œë“œ
        async function loadUserData() {
            if (userId === 'guest') return;
            
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/game_data/upgrades_doc`);
            
            try {
                const docSnap = await getDoc(docRef);
                if (docSnap.exists()) {
                    const data = docSnap.data();
                    userData.money = Number(data.money) || 0; // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜
                    userData.baseDamageLevel = Number(data.baseDamageLevel) || 0; // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜
                    userData.baseHPLevel = Number(data.baseHPLevel) || 0;     // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜
                    userData.baseRegenLevel = Number(data.baseRegenLevel) || 0;  // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜
                    userData.initialMoneyLevel = Number(data.initialMoneyLevel) || 0; // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜
                    userData.irradiateLevel = Number(data.irradiateLevel) || 0; // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜
                    userData.defensiveMatrixLevel = Number(data.defensiveMatrixLevel) || 0; // (ìˆ˜ì •) ë¡œë“œ ì‹œ Numberë¡œ ë³€í™˜

                    console.log("User Data Loaded:", userData);
                } else {
                    // ë¬¸ì„œê°€ ì—†ìœ¼ë©´ ìƒˆë¡œ ìƒì„± (ì´ˆê¸°ê°’ ì €ì¥)
                    await saveUserData(true);
                    console.log("New User Data Document Created.");
                }
            } catch (e) {
                console.error("User Data Load Failed:", e);
            }
            calculateSkillStats(); // ë°ì´í„° ë¡œë“œ í›„ ìŠ¤í‚¬ ìŠ¤íƒ¯ ê³„ì‚°
            updateMoneyDisplay(); // ë¡œë“œ í›„ ë¨¸ë‹ˆ UI ì—…ë°ì´íŠ¸
        }

        // Firestoreì— ì‚¬ìš©ì ë°ì´í„° ì €ì¥ (ì—…ê·¸ë ˆì´ë“œ ë° ëˆ)
        async function saveUserData(isInitial = false) {
            if (userId === 'guest') return;
            
            const docRef = doc(db, `artifacts/${appId}/users/${userId}/game_data/upgrades_doc`);
            
            try {
                const dataToSave = {
                    money: userData.money,
                    baseDamageLevel: userData.baseDamageLevel,
                    baseHPLevel: userData.baseHPLevel,
                    baseRegenLevel: userData.baseRegenLevel,    
                    initialMoneyLevel: userData.initialMoneyLevel, 
                    irradiateLevel: userData.irradiateLevel, // (ìˆ˜ì •) ë ˆë²¨ ì €ì¥
                    defensiveMatrixLevel: userData.defensiveMatrixLevel, // (ìˆ˜ì •) ë ˆë²¨ ì €ì¥
                    lastUpdated: Date.now()
                };
                
                if (isInitial) {
                    await setDoc(docRef, dataToSave);
                } else {
                    // ë°ì´í„°ë² ì´ìŠ¤ í˜¸ì¶œ ìµœì†Œí™”ë¥¼ ìœ„í•´ updateDoc ì‚¬ìš© (í•„ìš”í•œ ê²½ìš° setDocìœ¼ë¡œ ëŒ€ì²´ ê°€ëŠ¥)
                    await updateDoc(docRef, dataToSave); 
                }
                console.log("User Data Saved.");
            } catch (e) {
                console.error("User Data Save Failed:", e);
            }
        }
        // --- Firebase/Firestore ë¡œì§ ë ---


        // ëª¨ë“ˆ ìƒë‹¨ì— ì£¼ìš” ë³€ìˆ˜ ì„ ì–¸
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // UI ìš”ì†Œ
        const ui = {
            levelText: document.getElementById('level-text'),
            killCount: document.getElementById('kill-count'),
            timer: document.getElementById('timer'),
            bunkerHpFill: document.getElementById('bunker-hp-fill'),
            xpFill: document.getElementById('xp-fill'),
            startOverlay: document.getElementById('start-overlay'),
            levelUpOverlay: document.getElementById('level-up-overlay'),
            gameOverOverlay: document.getElementById('game-over-overlay'),
            upgradeContainer: document.getElementById('upgrade-container'),
            restartButton: document.getElementById('restart-button'),
            difficultyButtons: document.querySelectorAll('.diff-button[data-diff]'),
            // UI ìš”ì†Œ ì¶”ê°€
            marineCount: document.getElementById('marine-count'),
            firebatCount: document.getElementById('firebat-count'),
            tankCount: document.getElementById('tank-count'),
            ghostCount: document.getElementById('ghost-count'),
            monsterInfo: document.getElementById('monster-info'),
            // ì˜¤ë””ì˜¤ í† ê¸€ ë²„íŠ¼ ì¶”ê°€
            bgmToggle: document.getElementById('bgm-toggle'),
            sfxToggle: document.getElementById('sfx-toggle'),
            // (ì¶”ê°€) ì¼ì‹œì •ì§€ UI
            pauseOverlay: document.getElementById('pause-overlay'),
            pauseToggle: document.getElementById('pause-toggle'),
            // (ì¶”ê°€) ë¨¸ë‹ˆ UI
            moneyDisplay: document.getElementById('money-display'),
            // (ì¶”ê°€) ìƒì  UI
            permanentShopBtn: document.getElementById('permanent-shop-btn'),
            permanentShopOverlay: document.getElementById('permanent-shop-overlay'),
            shopMoneyInfo: document.getElementById('shop-money-info'),
            permanentUpgradeContainer: document.getElementById('permanent-upgrade-container'),
            closeShopBtn: document.getElementById('close-shop-btn'),
            loadingOverlay: document.getElementById('loading-overlay'),
            // (ì¶”ê°€) ìŠ¤í‚¬ UI
            skillIrradiate: document.getElementById('skill-irradiate'),
            skillDefMatrix: document.getElementById('skill-defmatrix'),
            skillIrradiateCooldown: document.getElementById('skill-irradiate-cooldown'),
            skillDefMatrixCooldown: document.getElementById('skill-defmatrix-cooldown'),
        };

        let gameState = {
            isRunning: false,
            isPaused: false, // ë ˆë²¨ì—… ì‹œ ë‚´ë¶€ ì¼ì‹œì •ì§€
            isLevelUp: false,
            isUserPaused: false, // (ì¶”ê°€) ì‚¬ìš©ì ì¼ì‹œì •ì§€
            startTime: 0,
            elapsedTime: 0, // ì´ ê²Œì„ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
            lastTime: 0,
            killCount: 0,
            playerBase: null, // Bunker -> PlayerBase
            enemies: [],
            projectiles: [],
            effects: [], // í­ë°œ/í™”ì—¼ íš¨ê³¼
            weapons: [],
            spawnTimer: 0,
            spawnInterval: 2500, // 2.5ì´ˆë§ˆë‹¤ ìŠ¤í° (ì´ˆë°˜ ë‚œì´ë„ í•˜í–¥)
            difficultyMultiplier: 1.0, // ë‚œì´ë„ ë°°ìœ¨
            lastMonsterInfo: "", // ëª¬ìŠ¤í„° ì •ë³´ ìºì‹œ
            // ì˜¤ë””ì˜¤ ìƒíƒœ ì¶”ê°€
            isBgmOn: true,
            isSfxOn: true,
            // (ì¶”ê°€) ìŠ¤í‚¬ ìƒíƒœ ê´€ë¦¬
            skills: {
                irradiate: {
                    lastUseTime: 0,
                    isActive: false,
                    durationRemaining: 0,
                },
                defensivematrix: {
                    lastUseTime: 0,
                    isActive: false,
                    durationRemaining: 0,
                }
            }
        };
        
        // ì˜¤ë””ì˜¤ ê´€ë ¨ ë³€ìˆ˜
        let isAudioInitialized = false;
        let sounds = {};


        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            if (gameState.playerBase) {
                gameState.playerBase.x = width / 2;
                gameState.playerBase.y = height / 2;
            }
        }
        
        // (ì¶”ê°€) ë‘ ì˜¤ë¸Œì íŠ¸ ê°„ì˜ ê±°ë¦¬ ê³„ì‚° í•¨ìˆ˜
        function distance(obj1, obj2) {
            const dx = obj1.x - obj2.x;
            const dy = obj1.y - obj2.y;
            return Math.sqrt(dx * dx + dy * dy);
        }


        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        // ë¨¸ë‹ˆ UI ì—…ë°ì´íŠ¸
        function updateMoneyDisplay() {
            ui.moneyDisplay.textContent = `ğŸ’° ${userData.money.toLocaleString()}`;
        }
        
        // ì˜¤ë””ì˜¤ ì´ˆê¸°í™” (ì‚¬ìš©ì ìƒí˜¸ì‘ìš© í›„ í˜¸ì¶œ)
        function initAudio() {
            if (isAudioInitialized) return;
            
            try {
                // ... ê¸°ì¡´ ì‚¬ìš´ë“œ ì •ì˜ ...
                sounds.marineSynth = new Tone.NoiseSynth({
                    noise: { type: 'white' },
                    envelope: { attack: 0.001, decay: 0.05, sustain: 0, release: 0.05 }
                }).toDestination();
                // (ìˆ˜ì •) gameState.isSfxOn ìƒíƒœì— ë”°ë¼ ì´ˆê¸° ë³¼ë¥¨ ì„¤ì •
                sounds.marineSynth.volume.value = gameState.isSfxOn ? 0 : -Infinity;
                
                sounds.firebatSynth = new Tone.NoiseSynth({
                    noise: { type: 'pink' },
                    envelope: { attack: 0.01, decay: 0.1, sustain: 0.1, release: 0.1 },
                    filter: { type: 'lowpass', Q: 2, frequency: 1000 },
                    filterEnvelope: { attack: 0.02, decay: 0.1, sustain: 0, release: 0.05, baseFrequency: 500, octaves: 2 }
                }).toDestination();
                // (ìˆ˜ì •) gameState.isSfxOn ìƒíƒœì— ë”°ë¼ ì´ˆê¸° ë³¼ë¥¨ ì„¤ì •
                sounds.firebatSynth.volume.value = gameState.isSfxOn ? 0 : -Infinity;
                
                sounds.tankSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.05,
                    octaves: 10,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 1.4, attackCurve: 'exponential' }
                }).toDestination();
                // (ìˆ˜ì •) gameState.isSfxOn ìƒíƒœì— ë”°ë¼ ì´ˆê¸° ë³¼ë¥¨ ì„¤ì •
                sounds.tankSynth.volume.value = gameState.isSfxOn ? -10 : -Infinity;

                sounds.ghostSynth = new Tone.FMSynth({
                    harmonicity: 3,
                    modulationIndex: 10,
                    detune: 0,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.001, decay: 0.1, sustain: 0.01, release: 0.2 },
                    modulation: { type: 'square' },
                    modulationEnvelope: { attack: 0.002, decay: 0.2, sustain: 0, release: 0.2 }
                }).toDestination();
                // (ìˆ˜ì •) gameState.isSfxOn ìƒíƒœì— ë”°ë¼ ì´ˆê¸° ë³¼ë¥¨ ì„¤ì •
                sounds.ghostSynth.volume.value = gameState.isSfxOn ? -10 : -Infinity;

                sounds.enemyHitSynth = new Tone.MembraneSynth({
                    pitchDecay: 0.01,
                    octaves: 5,
                    oscillator: { type: "sine" },
                    envelope: { attack: 0.001, decay: 0.2, sustain: 0, release: 0.1 }
                }).toDestination();
                // (ìˆ˜ì •) gameState.isSfxOn ìƒíƒœì— ë”°ë¼ ì´ˆê¸° ë³¼ë¥¨ ì„¤ì •
                sounds.enemyHitSynth.volume.value = gameState.isSfxOn ? -5 : -Infinity;

                // --- ë°°ê²½ìŒì•…(BGM) ì¶”ê°€ ---
                
                // (ì¶”ê°€) ì‹œë„¤ë§ˆí‹± íš¨ê³¼ë¥¼ ìœ„í•œ ë¦¬ë²„ë¸Œ
                const reverb = new Tone.Reverb({
                    decay: 4,
                    wet: 0.3
                }).toDestination();

                // (ìˆ˜ì •) BGM ì‹ ë””ì‚¬ì´ì €ë¥¼ ì›…ì¥í•œ íŒ¨ë“œ(AMSynth)ë¡œ ë³€ê²½
                // (ìƒˆ ìˆ˜ì •) MP3 ëŠë‚Œì„ ìœ„í•´ ì›…ì¥í•œ íŒ¨ë“œ + ë“œëŸ¼ìœ¼ë¡œ ë³€ê²½
                sounds.bgmSynth = new Tone.PolySynth(Tone.AMSynth, {
                    oscillator: { type: 'fatsawtooth' }, // ì›…ì¥í•œ íŒ¨ë“œ ì‚¬ìš´ë“œ
                    envelope: { attack: 1.5, decay: 0.5, sustain: 0.3, release: 1.0 }
                }).connect(reverb); // ë¦¬ë²„ë¸Œì— ì—°ê²°
                
                // (ìƒˆ ìˆ˜ì •) ë³¼ë¥¨ +10dBë¡œ ì„¤ì •
                sounds.bgmSynth.volume.value = gameState.isBgmOn ? +10 : -Infinity; 

                // (ì¶”ê°€) ì‹œë„¤ë§ˆí‹± ë“œëŸ¼ (ì¿µ ìš¸ë¦¬ëŠ” ì†Œë¦¬)
                sounds.bgmDrum = new Tone.MembraneSynth({
                    pitchDecay: 0.1,
                    octaves: 2,
                    oscillator: { type: 'sine' },
                    envelope: { attack: 0.01, decay: 0.5, sustain: 0.01, release: 0.5 }
                }).connect(reverb);
                // (ìˆ˜ì •) ë“œëŸ¼ ë³¼ë¥¨ë„ +10dBë¡œ ì„¤ì •
                sounds.bgmDrum.volume.value = gameState.isBgmOn ? +10 : -Infinity; 


                // (ìƒˆ ìˆ˜ì •) ì›…ì¥í•œ 1ë§ˆë”” íŒ¨í„´ìœ¼ë¡œ ë³€ê²½
                const bgmPattern = [
                    "C2", "G1", "F1", "A1" // ëŠë¦° ì½”ë“œ ì§„í–‰
                ];
                let patternIndex = 0;

                sounds.bgmLoop = new Tone.Loop(time => {
                    let note = bgmPattern[patternIndex % bgmPattern.length];
                    // (ìˆ˜ì •) 1ë§ˆë””(1m) ê¸¸ì´ë¡œ ì›…ì¥í•˜ê²Œ ì¬ìƒ
                    sounds.bgmSynth.triggerAttackRelease(note, "1m", time); 
                    
                    // (ì¶”ê°€) 1ë§ˆë””ì— í•œ ë²ˆì”© ë“œëŸ¼ ìš¸ë¦¼
                     sounds.bgmDrum.triggerAttackRelease("C1", "1n", time);
                    
                    patternIndex++;
                }, "1m"); // (ìˆ˜ì •) 1ë§ˆë””(1m) ê°„ê²©ìœ¼ë¡œ ë£¨í”„

                // BGM ì¬ìƒ ì‹œì‘
                sounds.bgmLoop.start(0);
                // (ìƒˆ ìˆ˜ì •) Transportë¥¼ ì—¬ê¸°ì„œ ì¦‰ì‹œ ì‹œì‘í•˜ê³ , ë³¼ë¥¨ìœ¼ë¡œë§Œ ì œì–´í•©ë‹ˆë‹¤.
                Tone.Transport.start();
                // --- BGM ì¶”ê°€ ì™„ë£Œ ---

                isAudioInitialized = true;
                console.log("ì˜¤ë””ì˜¤ê°€ ì„±ê³µì ìœ¼ë¡œ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤.");
            } catch (e) {
                console.error("ì˜¤ë””ì˜¤ ì´ˆê¸°í™” ì‹¤íŒ¨:", e);
            }
        }
        
        // (ì¶”ê°€) í”Œë¡œíŒ… í…ìŠ¤íŠ¸ í´ë˜ìŠ¤
        class FloatingText {
            constructor(x, y, text, color = '#FFFFFF', size = 18, vy = -0.5, duration = 800) {
                this.x = x;
                this.y = y;
                this.text = text;
                this.color = color;
                this.size = size;
                this.vy = vy;
                this.duration = duration;
                this.createdAt = Date.now();
                this.alpha = 1.0;
            }

            update(deltaTime) {
                const elapsed = Date.now() - this.createdAt;
                this.y += this.vy * (deltaTime / 16); // 16ms ê¸°ì¤€ ì†ë„ ë³´ì •
                this.alpha = 1.0 - (elapsed / this.duration); // íˆ¬ëª…ë„ ê°ì†Œ

                if (this.alpha <= 0) {
                    this.remove();
                }
            }

            draw() {
                ctx.globalAlpha = Math.max(0, this.alpha);
                ctx.fillStyle = this.color;
                ctx.font = `bold ${this.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.text, this.x, this.y);
                ctx.globalAlpha = 1.0; // ë³µì›
            }

            remove() {
                const index = gameState.effects.indexOf(this);
                if (index > -1) {
                    gameState.effects.splice(index, 1);
                }
            }
        }

        // ì‹œê° íš¨ê³¼ í´ë˜ìŠ¤ (í­ë°œ, í™”ì—¼ ë“±)
        class Effect {
            constructor(x, y, emoji, size, duration = 300) {
                this.x = x;
                this.y = y;
                this.emoji = emoji;
                this.duration = duration; // ë°€ë¦¬ì´ˆ
                this.createdAt = Date.now();
                this.size = size; 
            }

            update(deltaTime) {
                if (Date.now() - this.createdAt > this.duration) {
                    this.remove();
                }
            }

            draw() {
                ctx.globalAlpha = 0.7; // ì•½ê°„ ë°˜íˆ¬ëª…
                ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }

            remove() {
                const index = gameState.effects.indexOf(this);
                if (index > -1) {
                    gameState.effects.splice(index, 1);
                }
            }
        }


        // í”Œë ˆì´ì–´ ê¸°ì§€ í´ë˜ìŠ¤ (êµ¬ ë²™ì»¤)
        class PlayerBase {
            constructor() {
                this.x = width / 2;
                this.y = height / 2;
                this.radius = 35; // ì¶©ëŒ ë°˜ê²½
                this.color = '#8B4513'; // ê°ˆìƒ‰ (ìš¸íƒ€ë¦¬ìƒ‰)
                
                // (ìˆ˜ì •) ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ìŠ¤íƒ¯ ì ìš©
                const hpBonus = userData.baseHPLevel * permanentUpgrades.baseHP.effectPerLevel;
                const regenBonus = userData.baseRegenLevel * permanentUpgrades.baseRegen.effectPerLevel; // (ì¶”ê°€) ì¬ìƒ ì—…ê¸€ ì ìš©

                this.maxHp = 100 + hpBonus;
                this.hp = this.maxHp;
                this.level = 1;
                this.xp = 0;
                this.xpToNextLevel = 10;
                this.regen = 0.1 + regenBonus; // ì´ˆë‹¹ ì²´ë ¥ 0.1 + ì¬ìƒ ì—…ê¸€ ì ìš©
            }

            draw() {
                const size = this.radius * 2;
                const halfSize = this.radius;
                const x = this.x;
                const y = this.y;
                
                // 1. ë²™ì»¤ í•˜ë‹¨ í”Œë«í¼ (ì–´ë‘ìš´ íšŒìƒ‰)
                ctx.fillStyle = '#444444';
                ctx.beginPath();
                ctx.moveTo(x, y - halfSize);
                ctx.lineTo(x + halfSize, y);
                ctx.lineTo(x, y + halfSize);
                ctx.lineTo(x - halfSize, y);
                ctx.closePath();
                ctx.fill();

                // 2. ë²™ì»¤ ë³¸ì²´ (ë°ì€ íšŒìƒ‰)
                ctx.fillStyle = '#AAAAAA';
                ctx.beginPath();
                ctx.moveTo(x, y - halfSize * 0.8);
                ctx.lineTo(x + halfSize * 0.8, y);
                ctx.lineTo(x, y + halfSize * 0.8);
                ctx.lineTo(x - halfSize * 0.8, y);
                ctx.closePath();
                ctx.fill();
                
                // 3. ë²™ì»¤ ì¤‘ì•™ ë” (ì§„í•œ íšŒìƒ‰)
                ctx.fillStyle = '#666666';
                ctx.beginPath();
                ctx.arc(x, y, halfSize * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // 4. ì¶œêµ¬/ì…êµ¬ (ë¹¨ê°„ìƒ‰ ë””í…Œì¼)
                ctx.fillStyle = '#FF0000';
                ctx.fillRect(x - halfSize * 0.1, y - halfSize * 0.9, halfSize * 0.2, halfSize * 0.1);
                ctx.fillRect(x - halfSize * 0.1, y + halfSize * 0.8, halfSize * 0.2, halfSize * 0.1);
                ctx.fillRect(x - halfSize * 0.9, y - halfSize * 0.1, halfSize * 0.1, halfSize * 0.2);
                ctx.fillRect(x + halfSize * 0.8, y - halfSize * 0.1, halfSize * 0.1, halfSize * 0.2);
                
                // 5. HP/MP ë°”ë¥¼ ìœ„í•´ ì¤‘ì•™ì— ì‘ì€ ì› í‘œì‹œ
                ctx.fillStyle = '#1a1a1a';
                ctx.beginPath(); 
                ctx.arc(x, y, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            update(deltaTime) {
                // ì²´ë ¥ ì¬ìƒ
                if (this.regen > 0 && this.hp < this.maxHp) {
                    this.hp += this.regen * (deltaTime / 1000);
                    if (this.hp > this.maxHp) this.hp = this.maxHp;
                }
                
                ui.bunkerHpFill.style.width = `${(this.hp / this.maxHp) * 100}%`;
            }

            takeDamage(amount) {
                let damageTaken = amount;

                // (ì¶”ê°€) ë””íœì‹œë¸Œ ë§¤íŠ¸ë¦­ìŠ¤ ì ìš©
                if (gameState.skills.defensivematrix.isActive) {
                    damageTaken = SKILL_DATA.defensivematrix.damageCap; // 1 ë°ë¯¸ì§€ë¡œ ê³ ì •
                    // (ì¶”ê°€) ë°©ì–´ íš¨ê³¼ í…ìŠ¤íŠ¸
                    gameState.effects.push(new FloatingText(
                        this.x + (Math.random() * 20 - 10), 
                        this.y - this.radius - 20, 
                        'SHIELD!', 
                        '#00BFFF', // íŒŒë€ìƒ‰
                        20, 
                        -1.0, 
                        1000
                    ));
                }

                this.hp -= damageTaken;
                if (this.hp <= 0) {
                    this.hp = 0;
                    gameOver();
                }
                ui.bunkerHpFill.style.width = `${(this.hp / this.maxHp) * 100}%`;
            }

            gainXp(amount) {
                if (!gameState.isRunning) return;

                this.xp += amount;
                if (this.xp >= this.xpToNextLevel) {
                    this.levelUp();
                }
                ui.xpFill.style.width = `${(this.xp / this.xpToNextLevel) * 100}%`;
            }

            levelUp() {
                this.xp -= this.xpToNextLevel; // ë‚¨ì€ ê²½í—˜ì¹˜ ì´ì›”
                this.level++;
                this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5); // ë‹¤ìŒ ë ˆë²¨ í•„ìš” ê²½í—˜ì¹˜ ì¦ê°€
                ui.levelText.textContent = `LV. ${this.level}`;
                
                // ë ˆë²¨ì—… ì‹œ ì²´ë ¥ 100% íšŒë³µ
                this.hp = this.maxHp; 
                
                pauseGame(true);
                gameState.isLevelUp = true;
                showLevelUpUI();
            }
        }

        // ë¬´ê¸° í´ë˜ìŠ¤ (ë§ˆë¦°, íŒŒì´ì–´ë±ƒ, íƒ±í¬, ê³ ìŠ¤íŠ¸)
        class BunkerWeapon { // (ìˆ˜ì •) UnitWeapon -> BunkerWeaponìœ¼ë¡œ í´ë˜ìŠ¤ ì´ë¦„ ë³€ê²½
            constructor(type, owner) {
                this.type = type;
                this.owner = owner;
                this.level = 1;
                this.lastShotTime = Date.now() - (Math.random() * 200);
                
                // íƒ€ì…ë³„ ê³ ìœ  ìŠ¤íƒ¯ (ë ˆë²¨ì—…ìœ¼ë¡œ ë³€í•˜ì§€ ì•ŠëŠ” ê²ƒ)
                if (type === 'marine') {
                    this.projectileSpeed = 8;
                } else if (type === 'firebat') {
                    // ê³ ìœ  ìŠ¤íƒ¯ ì—†ìŒ (ì‚¬ê±°ë¦¬/ê³µì†/ë°ë¯¸ì§€ ëª¨ë‘ applyStatsì—ì„œ)
                } else if (type === 'tank') {
                    // this.aoeRadius ëŠ” applyStatsì—ì„œ ê´€ë¦¬
                } else if (type === 'ghost') {
                    this.projectileSpeed = 20; // ë¹ ë¦„
                }
                
                // ìƒì„±ìì—ì„œ applyStats()ë¥¼ í˜¸ì¶œí•˜ì—¬ ì´ˆê¸° ìŠ¤íƒ¯ ì„¤ì •
                this.applyStats();
            }

            update(deltaTime) {
                const now = Date.now();
                if (now - this.lastShotTime > this.attackSpeed) {
                    // ì‚¬ì •ê±°ë¦¬ ë‚´ì˜ ëª¨ë“  ì ì„ ì°¾ìŒ
                    const targetsInRange = gameState.enemies.filter(enemy => {
                        const dx = enemy.x - this.owner.x;
                        const dy = enemy.y - this.owner.y;
                        return Math.sqrt(dx * dx + dy * dy) <= this.range;
                    });
                    
                    if (targetsInRange.length > 0) {
                        let target; // íƒ±í¬, ê³ ìŠ¤íŠ¸, ë§ˆë¦°ì€ íƒ€ê²Ÿì´ í•„ìš”
                        
                        if (this.type === 'firebat') {
                            // íŒŒì´ì–´ë±ƒì€ íƒ€ê²Ÿ ì—†ì´ ê·¸ëƒ¥ ë°œì‚¬ (ê´‘ì—­ ê³µê²©)
                            this.shoot(null, targetsInRange); // ë²”ìœ„ ë‚´ ëª¨ë“  ì ì„ ì „ë‹¬
                        } else {
                            // ë§ˆë¦°, íƒ±í¬, ê³ ìŠ¤íŠ¸: ì‚¬ì •ê±°ë¦¬ ë‚´ ëœë¤ íƒ€ê²Ÿ (ë¶„ì‚° ê³µê²©)
                            // (ìˆ˜ì •) ëª¨ë“  ìœ ë‹›ì´ ì‚¬ê±°ë¦¬ ë‚´ì—ì„œ ëœë¤ ëŒ€ìƒì„ ê³µê²©í•˜ë„ë¡ ë³€ê²½
                            target = targetsInRange[Math.floor(Math.random() * targetsInRange.length)];
                            this.shoot(target);
                        }
                        this.lastShotTime = now + (Math.random() * 50);
                    }
                }
            }

            shoot(target, targetsInRange = []) { // íŒŒì´ì–´ë±ƒì„ ìœ„í•´ targetsInRange ì¶”ê°€
                // (ìˆ˜ì •) Tone.js ë™ì‹œ ì¬ìƒ ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•œ ì‘ì€ ëœë¤ ì˜¤í”„ì…‹ê³¼ shootTime ì •ì˜
                const shootTime = Tone.now(); // Tone.now() ì‚¬ìš©
                
                try { // (ì¶”ê°€) Tone.js ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•œ try-catch ë¸”ë¡
                    if (this.type === 'tank') {
                        // íƒ±í¬: ì¦‰ë°œ í­ë°œ ë° ë²”ìœ„ ë°ë¯¸ì§€
                        gameState.effects.push(new Effect(target.x, target.y, 'ğŸ’¥', 60)); // í­ë°œ í¬ê¸° 60
                        // (ìˆ˜ì •) shootTime ì‚¬ìš©
                        if (isAudioInitialized) sounds.tankSynth.triggerAttackRelease("C1", "0.5", shootTime); 
                        
                        // ë²”ìœ„ ë°ë¯¸ì§€
                        gameState.enemies.forEach(otherEnemy => {
                            const dxSplash = target.x - otherEnemy.x;
                            const dySplash = otherEnemy.y - otherEnemy.y;
                            if (Math.sqrt(dxSplash * dxSplash + dySplash * dySplash) < this.aoeRadius) {
                                otherEnemy.takeDamage(this.damage); // 100% ë²”ìœ„ ë°ë¯¸ì§€
                            }
                        });

                    } else if (this.type === 'firebat') {
                        // íŒŒì´ì–´ë±ƒ: ì¦‰ë°œ ê·¼ê±°ë¦¬ ë²”ìœ„ ë°ë¯¸ì§€ (íˆ¬ì‚¬ì²´ ì—†ìŒ)
                        // targetsInRange (ì´ë¯¸ ì‚¬ì •ê±°ë¦¬ ë‚´ì— ìˆëŠ” ì ë“¤)ì„ ë°”ë¡œ ê³µê²©
                        gameState.effects.push(new Effect(this.owner.x, this.owner.y, 'ğŸ”¥', this.range * 2, 200)); // í™”ì—¼ í¬ê¸° = ì‚¬ê±°ë¦¬*2, 0.2ì´ˆê°„ ì§€ì†
                        // (ìˆ˜ì •) shootTime ì‚¬ìš©
                        if (isAudioInitialized) sounds.firebatSynth.triggerAttackRelease("0.1", shootTime);
                        targetsInRange.forEach(enemy => {
                            enemy.takeDamage(this.damage);
                        });

                    } else {
                        // ë§ˆë¦°, ê³ ìŠ¤íŠ¸: íˆ¬ì‚¬ì²´ ë°œì‚¬
                        const dx = target.x - this.owner.x;
                        const dy = target.y - this.owner.y;
                        const dist = Math.sqrt(dx * dx + dy * dy);
                        
                        const velocityX = (dx / dist) * this.projectileSpeed;
                        const velocityY = (dy / dist) * this.projectileSpeed;
                        
                        // ì‚¬ìš´ë“œ ì¬ìƒ (isSfxOn ì²´í¬ëŠ” toggleSFXì—ì„œ ë³¼ë¥¨ìœ¼ë¡œ í•˜ë¯€ë¡œ ì—¬ê¸°ì„  í•„ìš” ì—†ìŒ)
                        if (isAudioInitialized) {
                            if (this.type === 'marine') {
                                // (ìˆ˜ì •) shootTime ì‚¬ìš©
                                sounds.marineSynth.triggerAttackRelease("0.05", shootTime);
                            } else if (this.type === 'ghost') {
                                // (ìˆ˜ì •) shootTime ì‚¬ìš©
                                sounds.ghostSynth.triggerAttackRelease("C4", "0.1", shootTime);
                            }
                        }

                        gameState.projectiles.push(new Projectile(
                            this.owner.x,
                            this.owner.y,
                            velocityX,
                            velocityY,
                            this.damage,
                            this.type
                        ));
                    }
                } catch (e) {
                    // console.warn("ì‚¬ìš´ë“œ ì¬ìƒ ì˜¤ë¥˜ ë°©ì§€ë¨ (ì‹œê°„ ì¶©ëŒ):", e.message); // ë””ë²„ê¹…ìš©
                }
            }

            applyStats() {
                // (ìˆ˜ì •) ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ìŠ¤íƒ¯ ì ìš©
                const damageBonus = userData.baseDamageLevel * permanentUpgrades.baseDamage.effectPerLevel;

                // ë ˆë²¨ì—… ìŠ¤íƒ¯ ì ìš© (ê³µì† ìƒí–¥ ë°˜ì˜)
                const levelBonus = this.level - 1;
                if (this.type === 'marine') {
                    this.damage = (4 + damageBonus) + levelBonus * 2; // ê¸°ë³¸ 4 + ì˜êµ¬ ë³´ë„ˆìŠ¤
                    this.attackSpeed = Math.max(150, 600 - levelBonus * 50); // ê¸°ë³¸ 600ms
                    this.range = 300 + levelBonus * 15; // ê¸°ë³¸ 300
                } else if (this.type === 'firebat') {
                    this.damage = (7 + damageBonus) + levelBonus * 3; // (ìˆ˜ì •) ê¸°ë³¸ 7 + ì˜êµ¬ ë³´ë„ˆìŠ¤
                    this.range = 120 + levelBonus * 10; // ê¸°ë³¸ 120
                    this.attackSpeed = Math.max(300, 1300 - levelBonus * 80); // ê¸°ë³¸ 1300
                } else if (this.type === 'tank') {
                    this.damage = (30 + damageBonus) + levelBonus * 5;
                    this.attackSpeed = Math.max(800, 2800 - levelBonus * 150); // ê¸°ë³¸ 2800
                    this.range = 550 + levelBonus * 20; // ê¸°ë³¸ 550
                    // (ìˆ˜ì •) ìŠ¤í”Œë˜ì‹œ ë²”ìœ„ ê°•í™” (70 -> 100, ë ˆë²¨ë‹¹ +15)
                    this.aoeRadius = 100 + levelBonus * 15; // ê¸°ë³¸ 100ìœ¼ë¡œ ì¦ê°€
                } else if (this.type === 'ghost') { // 'type' -> 'this.type'
                    this.damage = (50 + damageBonus) + levelBonus * 10;
                    this.attackSpeed = Math.max(1000, 3500 - levelBonus * 250); // ê¸°ë³¸ 3500
                    this.range = 450 + levelBonus * 15; // ê¸°ë³¸ 450
                }
            }
        }

        // ì´ì•Œ í´ë˜ìŠ¤ (íŒŒì´ì–´ë±ƒ ì œê±°)
        class Projectile {
            constructor(x, y, vx, vy, damage, type) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.damage = damage;
                this.type = type;
                this.pierce = false; // ê´€í†µ ì—†ìŒ
                
                if (type === 'marine') {
                    this.radius = 3;
                    this.color = '#FFFF00'; // ë…¸ë‘
                } else if (type === 'ghost') {
                    this.radius = 4;
                    this.color = '#00BFFF'; // í•˜ëŠ˜ìƒ‰
                }
            }

            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
                if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.remove();
                    return; // í•¨ìˆ˜ ì¢…ë£Œ
                }

                // ì¶©ëŒ ê°ì§€
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    if (!enemy) continue; // ì˜ˆì™¸ ì²˜ë¦¬

                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.radius + enemy.radius) {
                        // ë©”ì¸ íƒ€ê²Ÿ ë°ë¯¸ì§€
                        enemy.takeDamage(this.damage);
                        this.remove(); // ê´€í†µì´ ì•„ë‹ˆë¯€ë¡œ ì´ì•Œ ì œê±°
                        break; // ë°˜ë³µ ì¤‘ì§€
                    }
                }
            }

            draw() {
                // ì¼ë°˜ ì›
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            remove() {
                const index = gameState.projectiles.indexOf(this);
                if (index > -1) {
                    gameState.projectiles.splice(index, 1);
                }
            }
        }

        // ì  í´ë˜ìŠ¤
        class Enemy {
            constructor(type) {
                this.type = type;
                this.isAttacking = false;
                this.lastAttackTime = 0;
                this.attackCooldown = 1500; // 1.5ì´ˆ
                
                // ìŠ¤í° ìœ„ì¹˜ (í™”ë©´ ë°–)
                const spawnSide = Math.floor(Math.random() * 4);
                if (spawnSide === 0) { // Top
                    this.x = Math.random() * width;
                    this.y = -30;
                } else if (spawnSide === 1) { // Right
                    this.x = width + 30;
                    this.y = Math.random() * height;
                } else if (spawnSide === 2) { // Bottom
                    this.x = Math.random() * width;
                    this.y = height + 30;
                } else { // Left
                    this.x = -30;
                    this.y = Math.random() * height;
                }
                
                // íƒ€ì…ë³„ ìŠ¤íƒ¯ (ë‚œì´ë„ ë°°ìœ¨ ì ìš©)
                if (type === 'zergling') {
                    this.radius = 8; // 12 -> 8 (í¬ê¸° ê°ì†Œ)
                    this.speed = 1.0 + Math.random() * 0.3; // 1.5 -> 1.0 (ì†ë„ ê°ì†Œ)
                    this.maxHp = Math.ceil(5 * gameState.difficultyMultiplier);
                    this.damage = Math.ceil(1 * gameState.difficultyMultiplier);
                    this.xpValue = Math.max(1, Math.ceil(1 / (gameState.difficultyMultiplier * 0.5 + 0.5))); 
                    this.moneyValue = Math.ceil(2 * gameState.difficultyMultiplier); // (ì¶”ê°€) ëˆ íšë“
                    this.emoji = 'ğŸ›';
                } else if (type === 'hydralisk') {
                    this.radius = 11; // 16 -> 11 (í¬ê¸° ê°ì†Œ)
                    this.speed = 0.7 + Math.random() * 0.2; // 1.0 -> 0.7 (ì†ë„ ê°ì†Œ)
                    this.maxHp = Math.ceil(15 * gameState.difficultyMultiplier);
                    this.damage = Math.ceil(3 * gameState.difficultyMultiplier);
                    this.xpValue = Math.max(1, Math.ceil(3 / (gameState.difficultyMultiplier * 0.5 + 0.5)));
                    this.moneyValue = Math.ceil(5 * gameState.difficultyMultiplier); // (ì¶”ê°€) ëˆ íšë“
                    this.emoji = 'ğŸ';
                } else if (type === 'muta') {
                    this.radius = 7; // 10 -> 7 (í¬ê¸° ê°ì†Œ)
                    this.speed = 1.8 + Math.random() * 0.4; // 2.5 -> 1.8 (ì†ë„ ê°ì†Œ)
                    this.maxHp = Math.ceil(4 * gameState.difficultyMultiplier);
                    this.damage = Math.ceil(1 * gameState.difficultyMultiplier);
                    this.xpValue = Math.max(1, Math.ceil(1 / (gameState.difficultyMultiplier * 0.5 + 0.5)));
                    this.moneyValue = Math.ceil(3 * gameState.difficultyMultiplier); // (ì¶”ê°€) ëˆ íšë“
                    this.emoji = 'ğŸ¦‡';
                } else if (type === 'ultra') {
                    this.radius = 20; // 30 -> 20 (í¬ê¸° ê°ì†Œ)
                    this.speed = 0.6 + Math.random() * 0.1; // 0.8 -> 0.6 (ì†ë„ ê°ì†Œ)
                    this.maxHp = Math.ceil(100 * gameState.difficultyMultiplier);
                    this.damage = Math.ceil(10 * gameState.difficultyMultiplier);
                    this.xpValue = Math.max(5, Math.ceil(20 / (gameState.difficultyMultiplier * 0.5 + 0.5)));
                    this.moneyValue = Math.ceil(20 * gameState.difficultyMultiplier); // (ì¶”ê°€) ëˆ íšë“
                    this.emoji = 'ğŸ¦–';
                }
                this.hp = this.maxHp;
            }

            update(deltaTime) {
                const playerBase = gameState.playerBase;
                const dx = playerBase.x - this.x;
                const dy = playerBase.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // ê¸°ì§€ì™€ ë‹¿ì•˜ëŠ”ì§€ í™•ì¸
                if (dist < this.radius + playerBase.radius) {
                    this.isAttacking = true;
                } else {
                    this.isAttacking = false;
                }

                if (this.isAttacking) {
                    // ê³µê²©
                    const now = Date.now();
                    if (now - this.lastAttackTime > this.attackCooldown) {
                        playerBase.takeDamage(this.damage);
                        
                        // FIX: Enemy.update ì‚¬ìš´ë“œ ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•œ ëœë¤ ì˜¤í”„ì…‹ ì œê±° ë° try-catch ì¶”ê°€
                        if (isAudioInitialized) {
                            try { // (ì¶”ê°€) try-catchë¡œ ì˜ˆì•½ ì‹œê°„ ì¶©ëŒ ë°©ì–´
                                sounds.enemyHitSynth.triggerAttackRelease("A2", "0.1", Tone.now()); // ê¸°ì§€ í”¼ê²© ì‚¬ìš´ë“œ
                            } catch (e) {
                                // ì‚¬ìš´ë“œ ì¶©ëŒ ë¬´ì‹œ
                            }
                        }
                        
                        this.lastAttackTime = now;
                    }
                } else {
                    // ì´ë™
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }

            draw() {
                // ì´ëª¨ì§€ ê·¸ë¦¬ê¸°
                ctx.font = `${this.radius * 2}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);

                // ì²´ë ¥ë°”
                if (this.hp < this.maxHp) {
                    const hpBarWidth = this.radius * 2;
                    const hpBarHeight = 4;
                    const yOffset = this.y + this.radius + 5;
                    
                    ctx.fillStyle = '#FF0000'; // ë¹¨ê°„ìƒ‰ (ë°°ê²½)
                    ctx.fillRect(this.x - hpBarWidth / 2, yOffset, hpBarWidth, hpBarHeight);
                    
                    ctx.fillStyle = '#00FF00'; // ë…¹ìƒ‰ (í˜„ì¬ ì²´ë ¥)
                    ctx.fillRect(this.x - hpBarWidth / 2, yOffset, hpBarWidth * (this.hp / this.maxHp), hpBarHeight);
                }
                
                // (ìˆ˜ì •) ì´ë ˆë””ì—ì‡ íš¨ê³¼ ì‹œê°í™”
                if (gameState.skills.irradiate.isActive) {
                    const distToCenter = distance(this, gameState.playerBase);
                    if (distToCenter < SKILL_DATA_BASE.irradiate.radius) {
                        ctx.fillStyle = 'rgba(0, 255, 0, 0.5)'; // ì´ˆë¡ìƒ‰ DOT ì´í™íŠ¸
                        ctx.beginPath();
                        ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            }

            takeDamage(amount) {
                // (ìˆ˜ì •) ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ ìƒì„± ë¡œì§ ì¶”ê°€
                const damageTaken = Math.min(amount, this.hp); // ì‹¤ì œ ì…ëŠ” ë°ë¯¸ì§€
                const color = damageTaken >= 50 ? '#FF0000' : (damageTaken >= 10 ? '#FFFF00' : '#FFFFFF');
                gameState.effects.push(new FloatingText(
                    this.x + (Math.random() * 20 - 10), // xì¶• ëœë¤ ì˜¤í”„ì…‹
                    this.y - this.radius, 
                    Math.ceil(damageTaken).toString(), 
                    color
                ));
                
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.die(); // <-- ì´ í•¨ìˆ˜ê°€ ì—†ì—ˆìŒ
                }
            }

            // (ì¶”ê°€) Enemy í´ë˜ìŠ¤ì— die() ë©”ì„œë“œë¥¼ ì¶”ê°€
            die() {
                // (ìˆ˜ì •) ëˆ íšë“ ë¡œì§ ì¶”ê°€
                userData.money += this.moneyValue;
                updateMoneyDisplay();

                // ì  ë°°ì—´ì—ì„œ ì œê±°
                const index = gameState.enemies.indexOf(this);
                if (index > -1) {
                    gameState.enemies.splice(index, 1);
                }
                gameState.playerBase.gainXp(this.xpValue); // ì¦‰ì‹œ ê²½í—˜ì¹˜ íšë“

                gameState.killCount++;
                ui.killCount.textContent = `Kills: ${gameState.killCount}`;
            }
            // (ì¶”ê°€) die() ë©”ì„œë“œ ë
        }

        // ì—…ê·¸ë ˆì´ë“œ ëª©ë¡
        const allUpgrades = [
            { id: 'add_marine', title: 'ë§ˆë¦° ì¶©ì›', desc: 'ìƒˆë¡œìš´ ë§ˆë¦°ì„ ê¸°ì§€ì— ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 6ê¸°)' },
            { id: 'add_firebat', title: 'íŒŒì´ì–´ë±ƒ ì¶©ì›', desc: 'ê·¼ê±°ë¦¬ ê´‘ì—­ ê³µê²© íŒŒì´ì–´ë±ƒì„ ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 2ê¸°)' },
            { id: 'add_tank', title: 'ì‹œì¦ˆ íƒ±í¬ ì¶”ê°€', desc: 'ê°•ë ¥í•œ ë²”ìœ„ í”¼í•´ë¥¼ ì£¼ëŠ” íƒ±í¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 2ê¸°)' },
            { id: 'add_ghost', title: 'ê³ ìŠ¤íŠ¸ ì¶”ê°€', desc: 'ê°•ë ¥í•œ ì €ê²© ìœ ë‹› ê³ ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 2ê¸°)' },
            { id: 'upgrade_marine', title: 'ë§ˆë¦° ê³µê²©ë ¥/ì—°ì‚¬ë ¥ ì¦ê°€', desc: 'ëª¨ë“  ë§ˆë¦°ì˜ ê³µê²©ë ¥ê³¼ ê³µê²© ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'upgrade_firebat', title: 'íŒŒì´ì–´ë±ƒ í™”ì—¼ ê°•í™”', desc: 'ëª¨ë“  íŒŒì´ì–´ë±ƒì˜ ê³µê²©ë ¥ê³¼ ë²”ìœ„, ì—°ì‚¬ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'upgrade_tank', title: 'íƒ±í¬ í¬íƒ„ ê°•í™”', desc: 'ëª¨ë“  íƒ±í¬ì˜ ê³µê²©ë ¥ê³¼ ê³µê²© ì†ë„, ë²”ìœ„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'upgrade_ghost', title: 'ê³ ìŠ¤íŠ¸ ì €ê²©ì´ ê°•í™”', desc: 'ëª¨ë“  ê³ ìŠ¤íŠ¸ì˜ ê³µê²©ë ¥ê³¼ ì¡°ì¤€ ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'bunker_max_hp', title: 'ê¸°ì§€ ìµœëŒ€ ì²´ë ¥ ì¦ê°€', desc: 'ê¸°ì§€ì˜ ìµœëŒ€ ì²´ë ¥ì´ 25 ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'bunker_regen', title: 'ê¸°ì§€ ìë™ ìˆ˜ë¦¬', desc: 'ê¸°ì§€ì˜ ì´ˆë‹¹ ì²´ë ¥ ì¬ìƒ ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
        ];

        // í˜„ì¬ ê°€ëŠ¥í•œ ì—…ê·¸ë ˆì´ë“œ ëª©ë¡ í•„í„°ë§
        function getAvailableUpgrades() {
            const available = [];
            const marineCount = gameState.weapons.filter(w => w.type === 'marine').length;
            const firebatCount = gameState.weapons.filter(w => w.type === 'firebat').length;
            const tankCount = gameState.weapons.filter(w => w.type === 'tank').length;
            const ghostCount = gameState.weapons.filter(w => w.type === 'ghost').length;

            allUpgrades.forEach(upg => {
                if (upg.id === 'add_marine' && marineCount < 6) available.push(upg);
                else if (upg.id === 'add_firebat' && firebatCount < 2) available.push(upg);
                else if (upg.id === 'add_tank' && tankCount < 2) available.push(upg);
                else if (upg.id === 'add_ghost' && ghostCount < 2) available.push(upg);
                else if (upg.id === 'upgrade_marine' && marineCount > 0) available.push(upg);
                else if (upg.id === 'upgrade_firebat' && firebatCount > 0) available.push(upg);
                else if (upg.id === 'upgrade_tank' && tankCount > 0) available.push(upg);
                else if (upg.id === 'upgrade_ghost' && ghostCount > 0) available.push(upg);
                else if (upg.id === 'bunker_max_hp' || upg.id === 'bunker_regen') available.push(upg);
            });
            
            // 3ê°œ ëœë¤ ì„ íƒ (ì¤‘ë³µ ì—†ì´)
            const shuffled = available.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, 3);
        }

        // ë ˆë²¨ì—… UI í‘œì‹œ
        function showLevelUpUI() {
            ui.upgradeContainer.innerHTML = ''; // ì´ˆê¸°í™”
            const options = getAvailableUpgrades();
            
            options.forEach(option => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `<h3>${option.title}</h3><p>${option.desc}</p>`;
                div.onclick = () => selectUpgrade(option.id);
                ui.upgradeContainer.appendChild(div);
            });

            ui.levelUpOverlay.style.display = 'flex';
        }

        // ì—…ê·¸ë ˆì´ë“œ ì„ íƒ
        function selectUpgrade(id) {
            const playerBase = gameState.playerBase;
            
            switch (id) {
                case 'add_marine':
                    gameState.weapons.push(new BunkerWeapon('marine', playerBase)); // (ìˆ˜ì •) UnitWeapon -> BunkerWeapon
                    break;
                case 'add_firebat':
                    gameState.weapons.push(new BunkerWeapon('firebat', playerBase)); // (ìˆ˜ì •) UnitWeapon -> BunkerWeapon
                    break;
                case 'add_tank':
                    gameState.weapons.push(new BunkerWeapon('tank', playerBase)); // (ìˆ˜ì •) UnitWeapon -> BunkerWeapon
                    break;
                case 'add_ghost':
                    gameState.weapons.push(new BunkerWeapon('ghost', playerBase)); // (ìˆ˜ì •) UnitWeapon -> BunkerWeapon
                    break;
                
                case 'upgrade_marine':
                    gameState.weapons.filter(w => w.type === 'marine').forEach(w => { w.level++; w.applyStats(); });
                    break;
                case 'upgrade_firebat':
                     gameState.weapons.filter(w => w.type === 'firebat').forEach(w => { w.level++; w.applyStats(); });
                    break;
                case 'upgrade_tank':
                     gameState.weapons.filter(w => w.type === 'tank').forEach(w => { w.level++; w.applyStats(); });
                    break;
                case 'upgrade_ghost':
                     gameState.weapons.filter(w => w.type === 'ghost').forEach(w => { w.level++; w.applyStats(); });
                    break;

                case 'bunker_max_hp':
                    playerBase.maxHp += 25;
                    playerBase.hp += 25; // í˜„ì¬ ì²´ë ¥ë„ ì˜¬ë ¤ì¤Œ
                    break;
                case 'bunker_regen':
                    playerBase.regen += 0.2;
                    break;
            }

            updateUnitCountUI(); // ìœ ë‹› ìˆ˜ UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            ui.levelUpOverlay.style.display = 'none';
            gameState.isLevelUp = false;
            pauseGame(false); // ê²Œì„ ì¬ê°œ
        }

        // --- ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ ìƒì  ë¡œì§ ---

        // ì˜êµ¬ ìƒì  UI ì—…ë°ì´íŠ¸
        function showPermanentShop() {
            ui.shopMoneyInfo.textContent = `í˜„ì¬ ìê¸ˆ: ğŸ’° ${userData.money.toLocaleString()}`;
            ui.permanentUpgradeContainer.innerHTML = ''; // ì´ˆê¸°í™”

            const createUpgradeItem = (key, data) => {
                const isSkill = key.startsWith('buy');
                const userLevelKey = isSkill ? 
                                     (key === 'buyIrradiate' ? 'irradiateLevel' : 'defensiveMatrixLevel') // (ìˆ˜ì •) ìŠ¤í‚¬ í‚¤ë¥¼ ì§ì ‘ ì§€ì •í•˜ì—¬ ëŒ€ì†Œë¬¸ì ë¬¸ì œ í•´ê²°
                                     : `${key}Level`; // ì¼ë°˜ ì—…ê·¸ë ˆì´ë“œ
                
                // (ìˆ˜ì •) userData[userLevelKey]ê°€ undefinedì¼ ê²½ìš° 0ìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì´ˆê¸°í™”
                const currentLevel = Number(userData[userLevelKey]) || 0;
                
                let cost, isMax;
                
                // cost ê³„ì‚° ë¡œì§ì€ ê·¸ëŒ€ë¡œ ìœ ì§€
                cost = Math.ceil(data.costBase * Math.pow(data.costMultiplier, currentLevel));
                isMax = currentLevel >= data.maxLevel;

                let effectDesc;
                let levelText = `LV. ${currentLevel}/${data.maxLevel}`;
                
                if (isSkill) {
                    // [í•µì‹¬ ìˆ˜ì •]: SKILL_DATA_BASEì˜ í‚¤ëŠ” ì†Œë¬¸ìì´ë¯€ë¡œ ì†Œë¬¸ìë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
                    const skillName = key.substring(3).toLowerCase(); 
                    const baseData = SKILL_DATA_BASE[skillName];
                    const currentLvl = currentLevel;
                    const nextLvl = currentLevel + 1;

                    // baseDataê°€ undefinedì¼ ê²½ìš°, ì´ ì¡°ê±´ì„ í†µê³¼í•˜ë©´ ì˜¤ë¥˜ê°€ ë‚©ë‹ˆë‹¤.
                    // Firebase ë¡œë“œ ì „ì— ì´ í•¨ìˆ˜ê°€ í˜¸ì¶œë˜ê±°ë‚˜ ë°ì´í„° í‚¤ê°€ ì˜ëª»ëœ ê²½ìš°, 
                    // baseDataê°€ undefinedì¼ ìˆ˜ ìˆì§€ë§Œ, í˜„ì¬ ë¬¸ì œì˜ ì›ì¸ì€ ëŒ€ì†Œë¬¸ì ë¬¸ì œì´ë¯€ë¡œ, 
                    // baseDataëŠ” ì¡´ì¬í•œë‹¤ê³  ê°€ì •í•˜ê³  ì§„í–‰í•©ë‹ˆë‹¤. (ëŒ€ì†Œë¬¸ì ìˆ˜ì • í›„ì—ëŠ” ì •ìƒ ë™ì‘í•´ì•¼ í•¨)
                    if (!baseData) {
                         console.error(`Missing skill data for key: ${skillName}`);
                         return null; // ì˜¤ë¥˜ ë°©ì§€ë¥¼ ìœ„í•´ null ë°˜í™˜
                    }


                    if (currentLvl === 0) {
                        levelText = 'ë¯¸êµ¬ë§¤';
                        // ì²« êµ¬ë§¤ ì‹œ (ë ˆë²¨ 1)ì˜ íš¨ê³¼ í‘œì‹œ
                        const nextDuration = baseData.duration + (1 * baseData.durationIncreasePerLevel);
                        const nextCooldown = baseData.cooldown - (1 * baseData.cooldownDecreasePerLevel);

                        if (skillName === 'irradiate') {
                            effectDesc = `(LV.1) DOT ${Math.ceil(nextDuration / 1000)}ì´ˆ, ì¿¨ ${Math.ceil(nextCooldown / 1000)}ì´ˆ`;
                        } else {
                            effectDesc = `(LV.1) 1ë€ ìº¡ ${Math.ceil(nextDuration / 1000)}ì´ˆ, ì¿¨ ${Math.ceil(nextCooldown / 1000)}ì´ˆ`;
                        }

                    } else if (currentLvl < data.maxLevel) {
                         // ë ˆë²¨ì—… ì‹œ (ë‹¤ìŒ ë ˆë²¨)ì˜ íš¨ê³¼ í‘œì‹œ
                         const nextDuration = baseData.duration + (nextLvl * baseData.durationIncreasePerLevel);
                         const nextCooldown = baseData.cooldown - (nextLvl * baseData.cooldownDecreasePerLevel);

                         if (skillName === 'irradiate') {
                             effectDesc = `(LV.${nextLvl}) DOT ${Math.ceil(nextDuration / 1000)}ì´ˆ, ì¿¨ ${Math.ceil(nextCooldown / 1000)}ì´ˆ`;
                         } else {
                             effectDesc = `(LV.${nextLvl}) 1ë€ ìº¡ ${Math.ceil(nextDuration / 1000)}ì´ˆ, ì¿¨ ${Math.ceil(nextCooldown / 1000)}ì´ˆ`;
                         }
                    } else { // Max Level
                         // í˜„ì¬ (ìµœëŒ€ ë ˆë²¨)ì˜ íš¨ê³¼ í‘œì‹œ
                         const maxDuration = baseData.duration + (currentLvl * baseData.durationIncreasePerLevel);
                         const maxCooldown = baseData.cooldown - (currentLvl * baseData.cooldownDecreasePerLevel);

                         if (skillName === 'irradiate') {
                             effectDesc = `(LV.${currentLvl}) DOT ${Math.ceil(maxDuration / 1000)}ì´ˆ, ì¿¨ ${Math.ceil(maxCooldown / 1000)}ì´ˆ`;
                         } else {
                             effectDesc = `(LV.${currentLvl}) 1ë€ ìº¡ ${Math.ceil(maxDuration / 1000)}ì´ˆ, ì¿¨ ${Math.ceil(maxCooldown / 1000)}ì´ˆ`;
                         }
                    }
                } else {
                    if (key === 'baseDamage') effectDesc = `ë ˆë²¨ë‹¹ +${data.effectPerLevel} ê¸°ë³¸ ë°ë¯¸ì§€`;
                    else if (key === 'baseHP') effectDesc = `ë ˆë²¨ë‹¹ +${data.effectPerLevel} ìµœëŒ€ HP`;
                    else if (key === 'baseRegen') effectDesc = `ë ˆë²¨ë‹¹ +${data.effectPerLevel} ì´ˆë‹¹ HP ì¬ìƒ`;
                    else if (key === 'initialMoney') effectDesc = `ë ˆë²¨ë‹¹ +${data.effectPerLevel} ì‹œì‘ ìê¸ˆ`;
                    else effectDesc = "";
                }
                


                const div = document.createElement('div');
                div.className = 'upgrade-option';
                // (ìˆ˜ì •) Max Levelì¼ ë•Œ Level í‘œì‹œ
                const titleText = isMax ? `${data.title} (ìµœëŒ€ ë ˆë²¨)` : `${data.title} (${levelText})`;
                div.innerHTML = `
                    <h3>${titleText}</h3>
                    <p>${isMax ? 'ìµœëŒ€ íš¨ê³¼ ë‹¬ì„±.' : effectDesc}</p>
                    <p>${isMax ? 'ë” ì´ìƒ ì—…ê·¸ë ˆì´ë“œí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.' : `ë¹„ìš©: ğŸ’° ${cost.toLocaleString()}`}</p>
                `;

                if (!isMax && userData.money >= cost) {
                    div.style.cursor = 'pointer';
                    div.style.opacity = 1;
                    div.onclick = () => buyPermanentUpgrade(key, cost);
                } else {
                    div.style.cursor = 'default';
                    div.style.opacity = 0.6;
                }
                return div;
            };

            // (ìˆ˜ì •) createUpgradeItemì—ì„œ nullì´ ë°˜í™˜ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ, null ì²´í¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤.
            const baseDamageItem = createUpgradeItem('baseDamage', permanentUpgrades.baseDamage);
            if (baseDamageItem) ui.permanentUpgradeContainer.appendChild(baseDamageItem);

            const baseHPItem = createUpgradeItem('baseHP', permanentUpgrades.baseHP);
            if (baseHPItem) ui.permanentUpgradeContainer.appendChild(baseHPItem);
            
            const baseRegenItem = createUpgradeItem('baseRegen', permanentUpgrades.baseRegen);
            if (baseRegenItem) ui.permanentUpgradeContainer.appendChild(baseRegenItem);
            
            const initialMoneyItem = createUpgradeItem('initialMoney', permanentUpgrades.initialMoney);
            if (initialMoneyItem) ui.permanentUpgradeContainer.appendChild(initialMoneyItem);
            
            // ìŠ¤í‚¬ êµ¬ë§¤ ì˜µì…˜ ì¶”ê°€
            const irradiateItem = createUpgradeItem('buyIrradiate', permanentUpgrades.buyIrradiate);
            if (irradiateItem) ui.permanentUpgradeContainer.appendChild(irradiateItem);

            const defMatrixItem = createUpgradeItem('buyDefensiveMatrix', permanentUpgrades.buyDefensiveMatrix);
            if (defMatrixItem) ui.permanentUpgradeContainer.appendChild(defMatrixItem);
            
            ui.permanentShopOverlay.style.display = 'flex';
        }

        // ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œ êµ¬ë§¤
        function buyPermanentUpgrade(key, cost) {
            const data = permanentUpgrades[key];
            const isSkill = key.startsWith('buy');
            
            // (ìˆ˜ì •) ìŠ¤í‚¬ í‚¤ë¥¼ ëª…í™•í•˜ê²Œ ì§€ì •í•˜ê³ , ì¼ë°˜ ì—…ê·¸ë ˆì´ë“œëŠ” ê¸°ì¡´ ë¡œì§ì„ ë”°ë¥´ë˜ ì†Œë¬¸ìí™”
            let userLevelKey;
            if (key === 'buyIrradiate') {
                userLevelKey = 'irradiateLevel';
            } else if (key === 'buyDefensiveMatrix') {
                userLevelKey = 'defensiveMatrixLevel';
            } else {
                userLevelKey = `${key}Level`;
            }

            // (ìˆ˜ì •) Number()ë¥¼ ì‚¬ìš©í•˜ì—¬ í˜„ì¬ ë ˆë²¨ì´ í•­ìƒ ìœ íš¨í•œ ìˆ«ìì¸ì§€ í™•ì¸
            let currentLevel = Number(userData[userLevelKey]) || 0;
            
            if (currentLevel >= data.maxLevel) { 
                return; // ì´ë¯¸ ìµœëŒ€ ë ˆë²¨
            }


            if (userData.money >= cost) {
                userData.money -= cost;
                
                // ë ˆë²¨ ì¦ê°€
                userData[userLevelKey] = currentLevel + 1; // (ìˆ˜ì •) ì•ˆì „í•˜ê²Œ 1 ì¦ê°€
                
                // ìŠ¤í‚¬ ì—…ê·¸ë ˆì´ë“œì¼ ê²½ìš°, ìŠ¤íƒ¯ ì¬ê³„ì‚°
                if (isSkill) {
                    calculateSkillStats();
                    // ìŠ¤í‚¬ ë²„íŠ¼ í™œì„±í™” (ê²Œì„ì´ ì‹¤í–‰ ì¤‘ì¼ ê²½ìš°)
                    if (gameState.isRunning) {
                        if (userLevelKey === 'irradiateLevel') ui.skillIrradiate.disabled = false;
                        if (userLevelKey === 'defensiveMatrixLevel') ui.skillDefMatrix.disabled = false;
                    }
                }
                
                // ë°ì´í„° ì €ì¥ ë° UI ì—…ë°ì´íŠ¸
                updateMoneyDisplay();
                saveUserData(); 
                showPermanentShop(); // ìƒì  UI ìƒˆë¡œê³ ì¹¨

                console.log(`${data.title} ë ˆë²¨ ${userData[userLevelKey]} ì—…ê·¸ë ˆì´ë“œ ì™„ë£Œ.`);
            } else {
                console.log("ìê¸ˆì´ ë¶€ì¡±í•©ë‹ˆë‹¤.");
            }
        }
        
        
        // ë³´ìœ  ìœ ë‹› ìˆ˜ UI ì—…ë°ì´íŠ¸
        function updateUnitCountUI() {
            const marineCount = gameState.weapons.filter(w => w.type === 'marine').length;
            const firebatCount = gameState.weapons.filter(w => w.type === 'firebat').length;
            const tankCount = gameState.weapons.filter(w => w.type === 'tank').length;
            const ghostCount = gameState.weapons.filter(w => w.type === 'ghost').length;

            ui.marineCount.textContent = `ğŸ§‘â€ğŸš€ ${marineCount}`;
            ui.firebatCount.textContent = `ğŸ”¥ ${firebatCount}`;
            ui.tankCount.textContent = `ğŸ›¡ï¸ ${tankCount}`; // íƒ±í¬ ì•„ì´ì½˜
            ui.ghostCount.textContent = `ğŸ‘» ${ghostCount}`;
        }
        
        // ëª¬ìŠ¤í„° ì •ë³´ UI ì—…ë°ì´íŠ¸
        function updateMonsterInfoUI() {
            const time = gameState.elapsedTime;
            let info = "ë“±ì¥: ğŸ›";
            
            if (time > 30000) info += " ğŸ"; // 30ì´ˆ
            if (time > 60000) info += " ğŸ¦‡"; // 1ë¶„
            if (time > 180000) info += " ğŸ¦– (BOSS)"; // 3ë¶„

            if (info !== gameState.lastMonsterInfo) {
                ui.monsterInfo.textContent = info;
                gameState.lastMonsterInfo = info;
            }
        }


        // ê²Œì„ ìŠ¤í° ë¡œì§
        function handleSpawning(deltaTime) {
            // (ì¶”ê°€) deltaTimeì´ ìœ íš¨í•œ ê°’ì¼ ë•Œë§Œ íƒ€ì´ë¨¸ ì¦ê°€
            if (deltaTime <= 0) return;
            
            gameState.spawnTimer += deltaTime;
            // ë‚œì´ë„ ë°°ìœ¨ì— ë”°ë¼ ìŠ¤í° ê°„ê²© ì¡°ì ˆ
            const currentSpawnInterval = gameState.spawnInterval / gameState.difficultyMultiplier;

            if (gameState.spawnTimer > currentSpawnInterval) {
                gameState.spawnTimer = 0;
                
                // ë‚œì´ë„ ì¡°ì ˆ (ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ìŠ¤í° ê°„ê²© ì§§ì•„ì§)
                gameState.spawnInterval = Math.max(300, 2500 - gameState.elapsedTime / 1000 * 10); // 2500 ê¸°ì¤€ìœ¼ë¡œ
                
                let enemyType = 'zergling'; // ê¸°ë³¸
                const time = gameState.elapsedTime;
                
                if (time > 180000 && Math.random() < 0.05) { // 3ë¶„ í›„ ìš¸íŠ¸ë¼
                    enemyType = 'ultra';
                } else if (time > 60000 && Math.random() < 0.2) { // 1ë¶„ í›„ ë®¤íƒˆ
                    enemyType = 'muta';
                } else if (time > 30000 && Math.random() < 0.3) { // 30ì´ˆ í›„ íˆë“œë¼
                    enemyType = 'hydralisk';
                }
                
                gameState.enemies.push(new Enemy(enemyType));
            }
        }
        
        // (ì¶”ê°€) ìŠ¤í‚¬ ê´€ë¦¬ ë¡œì§
        function handleSkills(deltaTime) {
            const now = Date.now();
            
            // --- 1. ì´ë ˆë””ì—ì‡ (Irradiate) ---
            const irradiate = gameState.skills.irradiate;
            if (irradiate.isActive) {
                irradiate.durationRemaining -= deltaTime;
                const skillDotDamage = SKILL_DATA_BASE.irradiate.dotDamage * (deltaTime / 1000); // ì´ˆë‹¹ í”¼í•´ë¥¼ ë¸íƒ€ íƒ€ì„ì— ë§ì¶° ë¶„í• 
                
                // ë²™ì»¤ ì£¼ë³€ ì ì—ê²Œ DOT í”¼í•´ ì ìš©
                gameState.enemies.forEach(enemy => {
                    const dist = distance(enemy, gameState.playerBase);
                    if (dist < SKILL_DATA_BASE.irradiate.radius) {
                        // ë°ë¯¸ì§€ í…ìŠ¤íŠ¸ëŠ” 1ì´ˆë§ˆë‹¤ë§Œ í‘œì‹œ
                        if (gameState.elapsedTime % 1000 < deltaTime) {
                            gameState.effects.push(new FloatingText(
                                enemy.x + (Math.random() * 10 - 5), 
                                enemy.y - enemy.radius - 10, 
                                SKILL_DATA_BASE.irradiate.emoji, // (ìˆ˜ì •) ì´ëª¨ì§€ë¡œ í‘œì‹œ
                                '#00FF00', // ì´ˆë¡ìƒ‰ DOT
                                18, 
                                -0.3, 
                                800
                            ));
                        }
                        enemy.hp -= skillDotDamage;
                        if (enemy.hp <= 0) enemy.die();
                    }
                });

                if (irradiate.durationRemaining <= 0) {
                    irradiate.isActive = false;
                }
            }

            // ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
            if (irradiate.lastUseTime > 0) {
                const timeElapsed = now - irradiate.lastUseTime;
                const cooldownRemaining = Math.max(0, SKILL_DATA.irradiate.cooldown - timeElapsed);
                // UI ì—…ë°ì´íŠ¸
                if (cooldownRemaining > 0) {
                    ui.skillIrradiateCooldown.style.display = 'flex';
                    ui.skillIrradiateCooldown.textContent = Math.ceil(cooldownRemaining / 1000);
                } else {
                    ui.skillIrradiateCooldown.style.display = 'none';
                    if (userData.irradiateLevel > 0) ui.skillIrradiate.disabled = false; // (ìˆ˜ì •) ë ˆë²¨ > 0 ì¼ ë•Œ í™œì„±í™”
                }
            }
            
            // --- 2. ë””íœì‹œë¸Œ ë§¤íŠ¸ë¦­ìŠ¤ (Defensive Matrix) ---
            const defMatrix = gameState.skills.defensivematrix;
            if (defMatrix.isActive) {
                defMatrix.durationRemaining -= deltaTime;
                if (defMatrix.durationRemaining <= 0) {
                    defMatrix.isActive = false;
                }
            }

            // ì¿¨íƒ€ì„ ì—…ë°ì´íŠ¸
            if (defMatrix.lastUseTime > 0) {
                const timeElapsed = now - defMatrix.lastUseTime;
                const cooldownRemaining = Math.max(0, SKILL_DATA.defensivematrix.cooldown - timeElapsed);
                // UI ì—…ë°ì´íŠ¸
                if (cooldownRemaining > 0) {
                    ui.skillDefMatrixCooldown.style.display = 'flex';
                    ui.skillDefMatrixCooldown.textContent = Math.ceil(cooldownRemaining / 1000);
                } else {
                    ui.skillDefMatrixCooldown.style.display = 'none';
                    if (userData.defensiveMatrixLevel > 0) ui.skillDefMatrix.disabled = false; // (ìˆ˜ì •) userData.defensiveMatrixLevel ì‚¬ìš©
                }
            }
        }


        // ê²Œì„ ì¼ì‹œì •ì§€/ì¬ê°œ (ë ˆë²¨ì—… ì‹œ ì‚¬ìš©)
        function pauseGame(isPaused) {
            gameState.isPaused = isPaused;
            if (isPaused) {
                // BGMì€ ê³„ì† ì¬ìƒ
            } else {
                // (ìˆ˜ì •) lastTimeì„ 0ìœ¼ë¡œ ë¦¬ì…‹í•˜ì—¬ gameLoopê°€ timestampë¡œ ì¬ì„¤ì •í•˜ë„ë¡ í•¨
                // (Date.now() ì‚¬ìš© ì‹œ timestampì™€ ì–´ê¸‹ë‚˜ì„œ ìŒìˆ˜ deltaTime ë°œìƒ)
                gameState.lastTime = 0; 
                if (!gameState.isLevelUp && gameState.isRunning) { // ë ˆë²¨ì—…ì´ ì•„ë‹ ë•Œë§Œ gameLoop ì¬ì‹œì‘
                    requestAnimationFrame(gameLoop);
                }
            }
        }

        // ê²Œì„ ì˜¤ë²„ í•¨ìˆ˜ (ì˜¤ë¥˜ ìˆ˜ì •)
        function gameOver() {
            gameState.isRunning = false;
            document.getElementById('game-over-stats').textContent = `ìµœì¢… ìƒì¡´ ì‹œê°„: ${formatTime(gameState.elapsedTime)} | ìµœì¢… í‚¬ ìˆ˜: ${gameState.killCount}`;
            ui.gameOverOverlay.style.display = 'flex';
            saveUserData(); // ê²Œì„ ì˜¤ë²„ ì‹œ ëˆ ì €ì¥
        }

        // ë©”ì¸ ê²Œì„ ë£¨í”„ (ì˜¤ë¥˜ ìˆ˜ì •)
        function gameLoop(timestamp) {
            if (!gameState.isRunning) return; // ê²Œì„ ì˜¤ë²„ ì‹œ ì¤‘ì§€
            
            // (ìˆ˜ì •) ì²« í”„ë ˆì„ ë˜ëŠ” unpause ì‹œ lastTimeì„ ë¦¬ì…‹í•©ë‹ˆë‹¤.
            if (gameState.lastTime === 0) {
                gameState.lastTime = timestamp;
                requestAnimationFrame(gameLoop); // ë‹¤ìŒ í”„ë ˆì„ë¶€í„° ë¸íƒ€ ê³„ì‚° ì‹œì‘
                return;
            }
            
            if (gameState.isPaused || gameState.isLevelUp || gameState.isUserPaused) { // (ìˆ˜ì •) isUserPaused ì¶”ê°€
                // ê²Œì„ì´ ì¼ì‹œì •ì§€ (ë ˆë²¨ì—… ë˜ëŠ” ì‚¬ìš©ì ì¼ì‹œì •ì§€ í¬í•¨)
                gameState.lastTime = timestamp; // lastTimeì„ ì—…ë°ì´íŠ¸í•˜ì—¬ ì¼ì‹œì •ì§€ í•´ì œ ì‹œ deltaTimeì´ íŠ€ëŠ” ê²ƒì„ ë°©ì§€
                requestAnimationFrame(gameLoop); // ë£¨í”„ëŠ” ê³„ì† ëŒì§€ë§Œ,
                return; // ì—…ë°ì´íŠ¸/ê·¸ë¦¬ê¸°ëŠ” ê±´ë„ˆë›°m
            }

            let deltaTime = timestamp - gameState.lastTime;
            gameState.lastTime = timestamp; // lastTimeì„ í˜„ì¬ timestampë¡œ ì—…ë°ì´íŠ¸

            // (ì¶”ê°€) ë¹„ì •ìƒì ì¸ deltaTime ê°’ ë°©ì§€ (ì˜ˆ: ì°½ ë¹„í™œì„±í™” í›„ ë³µê·€, 1ì´ˆ=1000ms)
            // (ìŒìˆ˜ ê°’ë„ ì—¬ê¸°ì„œ ì°¨ë‹¨ë¨)
            if (deltaTime < 0 || deltaTime > 1000) {
                deltaTime = 0; // ë¹„ì •ìƒì ì¸ í”„ë ˆì„ì€ ê±´ë„ˆë›°ê³ , ë‹¤ìŒ í”„ë ˆì„ë¶€í„° ì •ìƒ ê³„ì‚°
            }

            gameState.elapsedTime += deltaTime;

            // --- 1. ì—…ë°ì´íŠ¸ (ë¡œì§) ---
            handleSpawning(deltaTime);
            gameState.playerBase.update(deltaTime);
            handleSkills(deltaTime); // (ì¶”ê°€) ìŠ¤í‚¬ ì—…ë°ì´íŠ¸
            
            // ë°°ì—´ ë³µì‚¬ë³¸ì„ ë§Œë“¤ì–´ ìˆœíšŒ (ì—…ë°ì´íŠ¸ ì¤‘ ë°°ì—´ì´ ìˆ˜ì •ë  ìˆ˜ ìˆìœ¼ë¯€ë¡œ)
            [...gameState.weapons].forEach(w => w.update(deltaTime));
            [...gameState.projectiles].forEach(p => p.update(deltaTime));
            [...gameState.enemies].forEach(e => e.update(deltaTime));
            [...gameState.effects].forEach(ef => ef.update(deltaTime)); // (ìˆ˜ì •) í”Œë¡œíŒ… í…ìŠ¤íŠ¸/íš¨ê³¼ ì—…ë°ì´íŠ¸
            
            // --- 2. ê·¸ë¦¬ê¸° (ì‹œê°) ---
            ctx.clearRect(0, 0, width, height);
            
            // ìˆœì„œëŒ€ë¡œ ê·¸ë¦¬ê¸° (íˆ¬ì‚¬ì²´ -> ì  -> ê¸°ì§€ -> íš¨ê³¼)
            [...gameState.projectiles].forEach(p => p.draw());
            // (ì¶”ê°€) ìŠ¤í‚¬ íš¨ê³¼ ê·¸ë¦¬ê¸°
            drawSkills(); 
            [...gameState.enemies].forEach(e => e.draw());
            gameState.playerBase.draw(); // ê¸°ì§€ ê·¸ë¦¬ê¸°
            [...gameState.effects].forEach(ef => ef.draw()); // (ìˆ˜ì •) í”Œë¡œíŒ… í…ìŠ¤íŠ¸/íš¨ê³¼ ê·¸ë¦¬ê¸°

            // --- 3. UI ì—…ë°ì´íŠ¸ ---
            ui.timer.textContent = formatTime(gameState.elapsedTime);
            updateMonsterInfoUI();

            // ë‹¤ìŒ í”„ë ˆì„ ìš”ì²­
            requestAnimationFrame(gameLoop);
        }

        // (ì¶”ê°€) ìŠ¤í‚¬ íš¨ê³¼ ê·¸ë¦¬ê¸°
        function drawSkills() {
            const base = gameState.playerBase;
            const now = Date.now();
            
            // 1. ë””íœì‹œë¸Œ ë§¤íŠ¸ë¦­ìŠ¤ ì‰´ë“œ (ìˆ˜ì •)
            if (gameState.skills.defensivematrix.isActive) {
                const skill = gameState.skills.defensivematrix;
                const totalDuration = SKILL_DATA.defensivematrix.duration;
                const remaining = skill.durationRemaining;
                const radius = base.radius + 15; // ì‰´ë“œ í¬ê¸°ë¥¼ ê¸°ì§€ë³´ë‹¤ ì¡°ê¸ˆ ë” í¬ê²Œ ì„¤ì •
                
                // (ìˆ˜ì •) ì´ëª¨ì§€ í¬ê¸°ë¥¼ 3ë°°(90px)ë¡œ í‚¤ìš°ê³  ì‰´ë“œì™€ ë™ì¼í•œ ìœ„ì¹˜ì— ê·¸ë¦½ë‹ˆë‹¤.
                const fontSize = 90; 
                
                let alpha = 0.8;
                
                // ì§€ì† ì‹œê°„ ë§ˆì§€ë§‰ 20% ë™ì•ˆ ê¹œë¹¡ì„ íš¨ê³¼ ì ìš©
                if (remaining < totalDuration * 0.2) {
                    if (now % 300 < 150) { // 0.3ì´ˆ ì£¼ê¸°ë¡œ ê¹œë¹¡ì„
                        alpha = 0.0;
                    }
                }
                
                ctx.strokeStyle = '#00BFFF';
                ctx.lineWidth = 5;
                ctx.globalAlpha = alpha;
                
                // ë°©ì–´ë§‰ ê·¸ë¦¬ê¸°
                ctx.beginPath();
                ctx.arc(base.x, base.y, radius, 0, Math.PI * 2);
                ctx.stroke();

                // ì´ëª¨ì§€ ê·¸ë¦¬ê¸° (ì‰´ë“œì™€ ë™ì¼í•œ ìœ„ì¹˜, í¬ê¸°)
                ctx.font = `bold ${fontSize}px sans-serif`;
                ctx.fillStyle = '#00BFFF';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(SKILL_DATA.defensivematrix.emoji, base.x, base.y);
                
                ctx.globalAlpha = 1.0;
            }

            // 2. ì´ë ˆë””ì—ì‡ íš¨ê³¼ ë²”ìœ„
            if (gameState.skills.irradiate.isActive) {
                const pulse = Math.sin(Date.now() / 100) * 0.1 + 0.15; // DOT ì˜ì—­ ê¹œë¹¡ì„
                ctx.fillStyle = `rgba(0, 255, 0, ${pulse})`;
                ctx.beginPath();
                ctx.arc(base.x, base.y, SKILL_DATA_BASE.irradiate.radius, 0, Math.PI * 2); // (ìˆ˜ì •) BASE.radius ì‚¬ìš©
                ctx.fill();
                
                // (ì¶”ê°€) ë°©ì‚¬ëŠ¥ ì´ëª¨ì§€ ê·¸ë¦¬ê¸°
                // (ìˆ˜ì •) ì´ëª¨ì§€ í¬ê¸°ë¥¼ 3ë°°(90px)ë¡œ í‚¤ì›ë‹ˆë‹¤.
                ctx.font = 'bold 90px sans-serif'; 
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(SKILL_DATA_BASE.irradiate.emoji, base.x, base.y); // (ìˆ˜ì •) BASE.emoji ì‚¬ìš©
                
                ctx.globalAlpha = 1.0;
            }
        }


        // ê²Œì„ ì¬ì‹œì‘ í•¨ìˆ˜ (ì˜¤ë¥˜ ìˆ˜ì •)
        function restartGame() {
            ui.gameOverOverlay.style.display = 'none';
            ui.startOverlay.style.display = 'flex';
            gameState.isRunning = false; // ë£¨í”„ ì¤‘ì§€
            saveUserData(); // ê²Œì„ ì˜¤ë²„ ì‹œ ëˆ ì €ì¥
        }
        
        // --- í•¨ìˆ˜ ì •ì˜ ë ---
        
        // (ì¶”ê°€) ìŠ¤í‚¬ ì‚¬ìš© í•¨ìˆ˜
        function useSkill(skillId) {
            if (!gameState.isRunning || gameState.isPaused || gameState.isLevelUp) return;
            
            const skill = gameState.skills[skillId];
            const now = Date.now();
            
            // ì¿¨íƒ€ì„ í™•ì¸
            if (now - skill.lastUseTime < SKILL_DATA[skillId].cooldown) {
                console.log(`${skillId} ì¿¨íƒ€ì„ì´ ë‚¨ì•˜ìŠµë‹ˆë‹¤.`);
                return;
            }

            // ìŠ¤í‚¬ í™œì„±í™”
            skill.isActive = true;
            skill.lastUseTime = now;
            // (ìˆ˜ì •) SKILL_DATAê°€ defensivematrix í‚¤ë¥¼ ì‚¬ìš©í•˜ë„ë¡ ìˆ˜ì •
            skill.durationRemaining = SKILL_DATA[skillId].duration; 
            
            // ë²„íŠ¼ ë¹„í™œì„±í™” ë° ì¿¨íƒ€ì„ í‘œì‹œ ì‹œì‘
            if (skillId === 'irradiate') {
                ui.skillIrradiate.disabled = true;
                ui.skillIrradiateCooldown.style.display = 'flex';
                // ì‚¬ìš´ë“œ: ì´ë ˆë””ì—ì‡ (Ghost Synth ì¬í™œìš©)
                if (isAudioInitialized) sounds.ghostSynth.triggerAttackRelease("G4", "0.2", Tone.now());
            } else if (skillId === 'defensivematrix') {
                ui.skillDefMatrix.disabled = true;
                ui.skillDefMatrixCooldown.style.display = 'flex';
                // ì‚¬ìš´ë“œ: ë””íœì‹œë¸Œ ë§¤íŠ¸ë¦­ìŠ¤ (Tank Synth ì¬í™œìš©)
                 if (isAudioInitialized) sounds.tankSynth.triggerAttackRelease("C3", "0.4", Tone.now());
            }
        }


        // ê²Œì„ ì‹œì‘
        function startGame(difficulty) {
            resizeCanvas(); // ì‹œì‘í•  ë•Œ ìº”ë²„ìŠ¤ í¬ê¸° ë§ì¶”ê¸°
            
            const playerBase = new PlayerBase();
            
            // (ìˆ˜ì •) gameState ê°ì²´ë¥¼ ìƒˆë¡œ ë®ì–´ì“°ëŠ” ëŒ€ì‹ , ì†ì„±ë§Œ ë¦¬ì…‹í•©ë‹ˆë‹¤.
            // ì´ë ‡ê²Œ í•˜ë©´ isBgmOn, isSfxOn ê°™ì€ ê¸°ì¡´ ì„¤ì •ì´ ìœ ì§€ë©ë‹ˆë‹¤.
            
            gameState.isRunning = true;
            gameState.isPaused = false;
            gameState.isLevelUp = false;
            gameState.isUserPaused = false; // (ì¶”ê°€)
            gameState.elapsedTime = 0;
            gameState.lastTime = 0; 
            gameState.killCount = 0;
            gameState.playerBase = playerBase;
            gameState.enemies = [];
            gameState.projectiles = [];
            gameState.effects = []; 
            gameState.weapons = [new BunkerWeapon('marine', playerBase)]; // (ìˆ˜ì •) UnitWeapon -> BunkerWeapon
            gameState.spawnTimer = 0;
            gameState.spawnInterval = 2500; 
            gameState.difficultyMultiplier = difficulty; 
            gameState.lastMonsterInfo = ""; 
            
            // (ì¶”ê°€) ìŠ¤í‚¬ ì¿¨íƒ€ì„ ì´ˆê¸°í™”
            gameState.skills.irradiate.lastUseTime = 0;
            gameState.skills.irradiate.isActive = false;
            gameState.skills.defensivematrix.lastUseTime = 0;
            gameState.skills.defensivematrix.isActive = false;

            
            // (ì¶”ê°€) ì˜êµ¬ ì—…ê·¸ë ˆì´ë“œëœ ì‹œì‘ ìê¸ˆ ì ìš©
            const moneyBonus = userData.initialMoneyLevel * permanentUpgrades.initialMoney.effectPerLevel;
            userData.money += moneyBonus;
            updateMoneyDisplay();

            // (ì¶”ê°€) ìŠ¤í‚¬ ë²„íŠ¼ ì´ˆê¸° ìƒíƒœ ì„¤ì •
            ui.skillIrradiate.disabled = userData.irradiateLevel === 0; // (ìˆ˜ì •) ë ˆë²¨ì´ 0ì´ë©´ ë¹„í™œì„±í™”
            ui.skillDefMatrix.disabled = userData.defensiveMatrixLevel === 0; // (ìˆ˜ì •) ë ˆë²¨ì´ 0ì´ë©´ ë¹„í™œì„±í™”
            ui.skillIrradiateCooldown.style.display = 'none';
            ui.skillDefMatrixCooldown.style.display = 'none';


            // UI ì´ˆê¸°í™”
            ui.startOverlay.style.display = 'none';
            ui.gameOverOverlay.style.display = 'none';
            ui.levelText.textContent = 'LV. 1';
            ui.killCount.textContent = 'Kills: 0';
            ui.timer.textContent = '00:00';
            ui.xpFill.style.width = '0%';
            ui.bunkerHpFill.style.width = '100%';
            ui.monsterInfo.textContent = 'ë“±ì¥: ğŸ›'; // ëª¬ìŠ¤í„° ì •ë³´ ì´ˆê¸°í™”
            ui.pauseOverlay.style.display = 'none'; // (ì¶”ê°€)
            ui.pauseToggle.textContent = 'PAUSE â¸ï¸'; // (ì¶”ê°€)
            ui.pauseToggle.classList.remove('off'); // (ì¶”ê°€)
            updateUnitCountUI(); // ìœ ë‹› ìˆ˜ ì´ˆê¸°í™”

            requestAnimationFrame(gameLoop);
        }

        // --- ì˜¤ë””ì˜¤ í† ê¸€ í•¨ìˆ˜ ---
        function toggleBGM() {
            // (ìˆ˜ì •) ì˜¤ë””ì˜¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ë‹¤ë©´, ì²« í´ë¦­ ì‹œ ì´ˆê¸°í™”ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.
            if (!isAudioInitialized) {
                Tone.start().then(initAudio).then(() => {
                    // initAudioê°€ ì™„ë£Œëœ í›„ ë¡œì§ ì‹¤í–‰
                    gameState.isBgmOn = !gameState.isBgmOn;
                    toggleBGMUI(gameState.isBgmOn); // UI ì—…ë°ì´íŠ¸ ë° Transport ì œì–´
                });
                return; // ì´ˆê¸°í™”ê°€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì¢…ë£Œ
            }
            
            gameState.isBgmOn = !gameState.isBgmOn;
            toggleBGMUI(gameState.isBgmOn); // UI ì—…ë°ì´íŠ¸ ë° Transport ì œì–´
        }

        // (ì¶”ê°€) BGM UI ë° Transport ì œì–´ ë¡œì§ ë¶„ë¦¬
        function toggleBGMUI(isOn) {
            if (isAudioInitialized) {
                // (ìˆ˜ì •) íŒ¨ë“œì™€ ë“œëŸ¼ ë³¼ë¥¨ì„ í•¨ê»˜ ì œì–´
                sounds.bgmSynth.volume.value = isOn ? +10 : -Infinity; // (ìµœì¢… ìˆ˜ì •) +10dBë¡œ í†µì¼
                sounds.bgmDrum.volume.value = isOn ? +10 : -Infinity; // (ìˆ˜ì •) ë“œëŸ¼ ë³¼ë¥¨ +10dB
                // (ì‚­ì œ) ë“œëŸ¼ ë³¼ë¥¨ ì œì–´ ì œê±°
                // (ìˆ˜ì •) Transport ì œì–´ ë¡œì§ì„ ì œê±°í•©ë‹ˆë‹¤. ë³¼ë¥¨ìœ¼ë¡œë§Œ ì œì–´í•©ë‹ˆë‹¤.
                /*
                if (isOn) { 
                    // BGMì„ ì¼œëŠ” ê²½ìš°
                    // (ìˆ˜ì •) ê²Œì„ ì‹¤í–‰ ì¤‘ ì—¬ë¶€ì™€ ê´€ê³„ì—†ì´ Transportë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.
                    Tone.Transport.start();
                } else {
                    // BGMì„ ë„ëŠ” ê²½ìš°
                    Tone.Transport.stop();
                }
                */
            }
            ui.bgmToggle.textContent = isOn ? 'BGM: ğŸµ' : 'BGM: ğŸ”‡';
            ui.bgmToggle.classList.toggle('off', !isOn);
        }

        function toggleSFX() {
             // (ìˆ˜ì •) ì˜¤ë””ì˜¤ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ë‹¤ë©´, ì²« í´ë¦­ ì‹œ ì´ˆê¸°í™”ë¥¼ ì‹œë„í•©ë‹ˆë‹¤.
            if (!isAudioInitialized) {
                Tone.start().then(initAudio).then(() => {
                    // initAudioê°€ ì™„ë£Œëœ í›„ ë¡œì§ ì‹¤í–‰
                    gameState.isSfxOn = !gameState.isSfxOn;
                    toggleSFXUI(gameState.isSfxOn); // UI ì—…ë°ì´íŠ¸
                });
                return; // ì´ˆê¸°í™”ê°€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‹¤í–‰ë˜ë¯€ë¡œ ì—¬ê¸°ì„œ ì¢…ë£Œ
            }
            
            gameState.isSfxOn = !gameState.isSfxOn;
            toggleSFXUI(gameState.isSfxOn); // UI ì—…ë°ì´íŠ¸
        }
        
        // (ì¶”ê°€) SFX UI ë° ë³¼ë¥¨ ì œì–´ ë¡œì§ ë¶„ë¦¬
        function toggleSFXUI(isOn) {
            if (isAudioInitialized) {
                const volume = isOn ? 0 : -Infinity;
                const tankVolume = isOn ? -10 : -Infinity;
                const ghostVolume = isOn ? -15 : -Infinity;
                const hitVolume = isOn ? -5 : -Infinity;

                sounds.marineSynth.volume.value = volume;
                sounds.firebatSynth.volume.value = volume;
                sounds.tankSynth.volume.value = tankVolume;
                sounds.ghostSynth.volume.value = ghostVolume;
                sounds.enemyHitSynth.volume.value = hitVolume;
            }
            
            ui.sfxToggle.textContent = isOn ? 'SFX: ğŸ”Š' : 'SFX: ğŸ”‡';
            ui.sfxToggle.classList.toggle('off', !isOn);
        } // (ìˆ˜ì •) ë‹«ëŠ” ì¤‘ê´„í˜¸ ì¶”ê°€

        // (ì¶”ê°€) ì‚¬ìš©ì ì¼ì‹œì •ì§€ í† ê¸€ í•¨ìˆ˜
        function toggleUserPause() {
            if (!gameState.isRunning) return; // ê²Œì„ì´ ì‹¤í–‰ ì¤‘ì¼ ë•Œë§Œ
            if (ui.permanentShopOverlay.style.display === 'flex') return; // (ì¶”ê°€) ìƒì  ì—´ë ¤ìˆì„ ë•ŒëŠ” ì´ ë²„íŠ¼ ë¬´ì‹œ

            gameState.isUserPaused = !gameState.isUserPaused;

            if (gameState.isUserPaused) {
                // ê²Œì„ ì¼ì‹œì •ì§€
                ui.pauseOverlay.style.display = 'flex';
                ui.pauseToggle.textContent = 'RESUME â–¶ï¸';
                ui.pauseToggle.classList.add('off');
                // BGMì€ ê³„ì† ì¬ìƒ
            } else {
                // ê²Œì„ ì¬ê°œ
                ui.pauseOverlay.style.display = 'none';
                ui.pauseToggle.textContent = 'PAUSE â¸ï¸';
                ui.pauseToggle.classList.remove('off');
                
                // lastTimeì„ ë¦¬ì…‹í•˜ì—¬ deltaTimeì´ íŠ€ëŠ” ê²ƒì„ ë°©ì§€
                gameState.lastTime = 0; 
                requestAnimationFrame(gameLoop);
            }
        }
        
        // (ì¶”ê°€) ì˜êµ¬ ìƒì  í† ê¸€ í•¨ìˆ˜
        function togglePermanentShop() {
            if (ui.permanentShopOverlay.style.display === 'flex') {
                // ìƒì  ë‹«ê¸°
                ui.permanentShopOverlay.style.display = 'none';
                
                // (ìˆ˜ì •) ê²Œì„ì´ ì‹¤í–‰ ì¤‘ì´ì—ˆê³  ìƒì ìœ¼ë¡œ ì¸í•´ ì¼ì‹œì •ì§€ëœ ìƒíƒœë¼ë©´ ì¬ê°œ
                if (gameState.isRunning && gameState.isUserPaused) { 
                    gameState.isUserPaused = false; // ì¼ì‹œì •ì§€ í•´ì œ
                    gameState.lastTime = 0; // ì‹œê°„ ë¦¬ì…‹
                    requestAnimationFrame(gameLoop);
                }
            } else {
                // ìƒì  ì—´ê¸°
                 if (gameState.isRunning && !gameState.isUserPaused) {
                    // (ìˆ˜ì •) ê²Œì„ ìƒíƒœë§Œ ì¼ì‹œì •ì§€. PAUSE UIëŠ” ê±´ë“œë¦¬ì§€ ì•ŠìŒ.
                    gameState.isUserPaused = true;
                    ui.pauseOverlay.style.display = 'none'; // í˜¹ì‹œ ëª¨ë¥¼ PAUSED ì˜¤ë²„ë ˆì´ ë°©ì§€
                }
                showPermanentShop();
            }
        }


        // --- ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ ---
        
        // ë‚œì´ë„ ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ
        ui.difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const difficulty = parseFloat(button.dataset.diff);
                // (ìˆ˜ì •) ì˜¤ë””ì˜¤ëŠ” ë‚œì´ë„ ì„ íƒ ì‹œì ì— ì´ˆê¸°í™”ë˜ì–´ì•¼ í•©ë‹ˆë‹¤.
                if (!isAudioInitialized) {
                    // (ìˆ˜ì •) initAudioê°€ ì™„ë£Œëœ í›„ startGameì´ ì‹¤í–‰ë˜ë„ë¡ .then() ì‚¬ìš©
                    Tone.start().then(initAudio).then(() => {
                        startGame(difficulty);
                    });
                } else {
                    startGame(difficulty);
                }
            });
        });

        // ìœˆë„ìš° ë¦¬ì‚¬ì´ì¦ˆ ì´ë²¤íŠ¸
        window.addEventListener('resize', resizeCanvas);
        
        // (ìˆ˜ì •) restartButton ë¦¬ìŠ¤ë„ˆ ìœ„ì¹˜ ìˆ˜ì •
        ui.restartButton.addEventListener('click', () => { 
            ui.gameOverOverlay.style.display = 'none';
            ui.startOverlay.style.display = 'flex';
            gameState.isRunning = false; // ë£¨í”„ ì¤‘ì§€
            saveUserData(); // ê²Œì„ ì˜¤ë²„ ì‹œ ëˆ ì €ì¥
        }); 

        // ìƒì  ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ
        ui.permanentShopBtn.addEventListener('click', togglePermanentShop);

        // ìƒì  ë‹«ê¸° ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ
        ui.closeShopBtn.addEventListener('click', togglePermanentShop);

        // (ì¶”ê°€) ìŠ¤í‚¬ ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ
        ui.skillIrradiate.addEventListener('click', () => useSkill('irradiate'));
        ui.skillDefMatrix.addEventListener('click', () => useSkill('defensivematrix'));


        // ì˜¤ë””ì˜¤ í† ê¸€ ë²„íŠ¼ ë¦¬ìŠ¤ë„ˆ
        ui.bgmToggle.addEventListener('click', toggleBGM);
        ui.sfxToggle.addEventListener('click', toggleSFX);
        ui.pauseToggle.addEventListener('click', toggleUserPause); // (ì¶”ê°€)

        // --- ì´ˆê¸°í™” ë° ì‹¤í–‰ ---
        resizeCanvas();
        // (ìˆ˜ì •) Firebase ì´ˆê¸°í™” ë° ë°ì´í„° ë¡œë“œ í›„ ì‹œì‘ ì˜¤ë²„ë ˆì´ í‘œì‹œ
        initFirebase().then(() => {
            ui.loadingOverlay.style.display = 'none';
            ui.startOverlay.style.display = 'flex';
        });
        
    </script>
</body>
</html>
