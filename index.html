<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ë²™ì»¤ ë””íœìŠ¤</title>
    <style>
        body {
            font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
            background-color: #1a1a1a;
            color: #f0f0f0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            overflow: hidden;
        }
        #game-container {
            position: relative;
            width: 100%;
            height: 100%;
            max-width: 100vw;
            max-height: 100vh;
            overflow: hidden;
            background-color: #2b2b2b; /* ì–´ë‘ìš´ ë°°ê²½ */
        }
        canvas {
            display: block;
            background-color: #333;
            width: 100%;
            height: 100%;
        }
        #ui-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }
        #top-ui, #bottom-ui {
            padding: 15px 20px;
            background: rgba(0, 0, 0, 0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        #top-ui {
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }
         #bottom-ui {
            border-top: 2px solid rgba(255, 255, 255, 0.1);
            flex-direction: column;
            align-items: stretch;
            gap: 10px;
        }
        #bunker-hp-bar {
            width: 100%;
            height: 20px;
            background-color: #555;
            border: 1px solid #777;
            border-radius: 10px;
            overflow: hidden;
        }
        #bunker-hp-fill {
            width: 100%;
            height: 100%;
            background-color: #4CAF50; /* ë…¹ìƒ‰ */
            transition: width 0.3s ease;
        }
        #xp-bar {
            width: 100%;
            height: 10px;
            background-color: #555;
            border: 1px solid #777;
            border-radius: 5px;
            overflow: hidden;
        }
        #xp-fill {
            width: 0%;
            height: 100%;
            background-color: #3498db; /* íŒŒë€ìƒ‰ */
            transition: width 0.3s ease;
        }
        #stats {
            display: flex;
            gap: 20px;
            font-size: 1.1em;
            font-weight: bold;
        }
        #level-text, #kill-count, #timer {
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        
        /* ë³´ìœ  ìœ ë‹› í‘œì‹œ */
        #unit-display {
            display: flex;
            gap: 15px;
            font-size: 1.2em;
            font-weight: bold;
            color: #fff;
        }
        #unit-display span {
            display: inline-flex;
            align-items: center;
            gap: 5px;
        }

        /* ëª¬ìŠ¤í„° ì •ë³´ í‘œì‹œ */
        #monster-info {
            text-align: center;
            font-size: 1.1em;
            font-weight: bold;
            color: #ddd;
            padding-bottom: 5px;
        }

        /* ì˜¤ë²„ë ˆì´ (ì‹œì‘, ë ˆë²¨ì—…, ê²Œì„ì˜¤ë²„) */
        .overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            pointer-events: auto;
            z-index: 10;
        }
        .overlay h1 {
            font-size: 3em;
            color: #fff;
            margin-bottom: 20px;
            text-shadow: 3px 3px 5px rgba(0,0,0,0.7);
        }
        .overlay p {
            font-size: 1.2em;
            color: #ddd;
            margin-bottom: 30px;
        }

        /* ë‚œì´ë„ ë²„íŠ¼ */
        #difficulty-select {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 80%;
            max-width: 300px;
        }
        .diff-button {
            font-family: inherit;
            font-size: 1.3em;
            font-weight: bold;
            padding: 15px 20px;
            border: none;
            border-radius: 12px;
            color: white;
            cursor: pointer;
            box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
            transition: all 0.2s ease;
        }
        .diff-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.4);
        }
        #diff-1 { background-color: #4CAF50; } /* ì•„ì£¼ ì‰¬ì›€ */
        #diff-1:hover { background-color: #45a049; }
        #diff-2 { background-color: #3498db; } /* ì‰¬ì›€ */
        #diff-2:hover { background-color: #2980b9; }
        #diff-3 { background-color: #7f8c8d; } /* ë³´í†µ */
        #diff-3:hover { background-color: #717d7e; }
        #diff-4 { background-color: #f1c40f; } /* ì¡°ê¸ˆ ì–´ë ¤ì›€ */
        #diff-4:hover { background-color: #f39c12; }
        #diff-5 { background-color: #e74c3c; } /* ë§¤ìš° ì–´ë ¤ì›€ */
        #diff-5:hover { background-color: #c0392b; }


        #upgrade-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 80%;
            max-width: 400px;
        }
        .upgrade-option {
            background: #444;
            padding: 20px;
            border-radius: 10px;
            border: 2px solid #555;
            cursor: pointer;
            transition: all 0.2s ease;
            box-shadow: 0 3px 8px rgba(0,0,0,0.3);
        }
        .upgrade-option:hover {
            background: #555;
            border-color: #777;
            transform: translateY(-3px);
        }
        .upgrade-option h3 {
            margin: 0 0 5px 0;
            color: #3498db; /* íŒŒë€ìƒ‰ */
        }
        .upgrade-option p {
            margin: 0;
            color: #ccc;
            font-size: 0.9em;
        }

        #game-over-overlay {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
        }
        
        #start-overlay {
            display: flex; /* ì²˜ìŒì—” ë³´ì„ */
        }

        #level-up-overlay {
            display: none; /* í‰ì†Œì—” ìˆ¨ê¹€ */
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas"></canvas>
        <div id="ui-container">
            <div id="top-ui">
                <div id="stats">
                    <span id="level-text">LV. 1</span>
                    <span id="kill-count">Kills: 0</span>
                    <span id="timer">00:00</span>
                </div>
                <!-- ë³´ìœ  ìœ ë‹› í‘œì‹œ UI -->
                <div id="unit-display">
                    <span id="marine-count">ğŸ§‘â€ğŸš€ 0</span>
                    <span id="firebat-count">ğŸ”¥ 0</span>
                    <span id="tank-count">ğŸ›¡ï¸ 0</span>
                    <span id="ghost-count">ğŸ‘» 0</span>
                </div>
            </div>
            <div id="bottom-ui">
                <!-- ëª¬ìŠ¤í„° ì •ë³´ UI -->
                <div id="monster-info">ë“±ì¥: ğŸ›</div>
                <div id="bunker-hp-bar">
                    <div id="bunker-hp-fill"></div>
                </div>
                <div id="xp-bar">
                    <div id="xp-fill"></div>
                </div>
            </div>
        </div>

        <!-- ê²Œì„ ì‹œì‘ ì˜¤ë²„ë ˆì´ -->
        <div id="start-overlay" class="overlay">
            <h1>ê¸°ì§€ ë°©ì–´</h1>
            <p>ë‚œì´ë„ë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
            <!-- ë‚œì´ë„ ì„ íƒ ë²„íŠ¼ (ë°°ìœ¨ ìˆ˜ì •) -->
            <div id="difficulty-select">
                <button id="diff-1" class="diff-button" data-diff="0.6">ì•„ì£¼ ì‰¬ì›€</button>
                <button id="diff-2" class="diff-button" data-diff="0.8">ì‰¬ì›€</button>
                <button id="diff-3" class="diff-button" data-diff="1.2">ë³´í†µ</button>
                <button id="diff-4" class="diff-button" data-diff="1.8">ì¡°ê¸ˆ ì–´ë ¤ì›€</button>
                <button id="diff-5" class="diff-button" data-diff="2.5">ë§¤ìš° ì–´ë ¤ì›€</button>
            </div>
        </div>

        <!-- ë ˆë²¨ì—… ì˜¤ë²„ë ˆì´ -->
        <div id="level-up-overlay" class="overlay">
            <h1>ë ˆë²¨ ì—…!</h1>
            <p>ì—…ê·¸ë ˆì´ë“œë¥¼ ì„ íƒí•˜ì„¸ìš”.</p>
            <div id="upgrade-container">
                <!-- ì—…ê·¸ë ˆì´ë“œ ì˜µì…˜ì´ ë™ì ìœ¼ë¡œ ì±„ì›Œì§‘ë‹ˆë‹¤. -->
            </div>
        </div>

        <!-- ê²Œì„ ì˜¤ë²„ ì˜¤ë²„ë ˆì´ -->
        <div id="game-over-overlay" class="overlay">
            <h1>ê²Œì„ ì˜¤ë²„</h1>
            <p id="game-over-stats">ìµœì¢… ìƒì¡´ ì‹œê°„: 00:00 | ìµœì¢… í‚¬ ìˆ˜: 0</p>
            <button id="restart-button" class="diff-button" style="background-color: #4CAF50;">ë‹¤ì‹œ ì‹œì‘</button>
        </div>
    </div>

    <script type="module">
        // ëª¨ë“ˆ ìƒë‹¨ì— ì£¼ìš” ë³€ìˆ˜ ì„ ì–¸
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        let width, height;

        // UI ìš”ì†Œ
        const ui = {
            levelText: document.getElementById('level-text'),
            killCount: document.getElementById('kill-count'),
            timer: document.getElementById('timer'),
            bunkerHpFill: document.getElementById('bunker-hp-fill'),
            xpFill: document.getElementById('xp-fill'),
            startOverlay: document.getElementById('start-overlay'),
            levelUpOverlay: document.getElementById('level-up-overlay'),
            gameOverOverlay: document.getElementById('game-over-overlay'),
            upgradeContainer: document.getElementById('upgrade-container'),
            restartButton: document.getElementById('restart-button'),
            difficultyButtons: document.querySelectorAll('.diff-button[data-diff]'),
            // UI ìš”ì†Œ ì¶”ê°€
            marineCount: document.getElementById('marine-count'),
            firebatCount: document.getElementById('firebat-count'),
            tankCount: document.getElementById('tank-count'),
            ghostCount: document.getElementById('ghost-count'),
            monsterInfo: document.getElementById('monster-info'),
        };

        let gameState = {
            isRunning: false,
            isPaused: false,
            isLevelUp: false,
            startTime: 0,
            elapsedTime: 0, // ì´ ê²Œì„ ì‹œê°„ (ë°€ë¦¬ì´ˆ)
            lastTime: 0,
            killCount: 0,
            playerBase: null, // Bunker -> PlayerBase
            enemies: [],
            projectiles: [],
            effects: [], // í­ë°œ/í™”ì—¼ íš¨ê³¼
            weapons: [],
            spawnTimer: 0,
            spawnInterval: 2500, // 2.5ì´ˆë§ˆë‹¤ ìŠ¤í° (ì´ˆë°˜ ë‚œì´ë„ í•˜í–¥)
            difficultyMultiplier: 1.0, // ë‚œì´ë„ ë°°ìœ¨
            lastMonsterInfo: "" // ëª¬ìŠ¤í„° ì •ë³´ ìºì‹œ
        };

        // ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
        function formatTime(ms) {
            const totalSeconds = Math.floor(ms / 1000);
            const minutes = Math.floor(totalSeconds / 60).toString().padStart(2, '0');
            const seconds = (totalSeconds % 60).toString().padStart(2, '0');
            return `${minutes}:${seconds}`;
        }

        // ìº”ë²„ìŠ¤ í¬ê¸° ì¡°ì ˆ
        function resizeCanvas() {
            width = canvas.width = window.innerWidth;
            height = canvas.height = window.innerHeight;
            
            if (gameState.playerBase) {
                gameState.playerBase.x = width / 2;
                gameState.playerBase.y = height / 2;
            }
        }
        
        // ì‹œê° íš¨ê³¼ í´ë˜ìŠ¤ (í­ë°œ, í™”ì—¼ ë“±)
        class Effect {
            constructor(x, y, emoji, size, duration = 300) {
                this.x = x;
                this.y = y;
                this.emoji = emoji;
                this.duration = duration; // ë°€ë¦¬ì´ˆ
                this.createdAt = Date.now();
                this.size = size; 
            }

            update(deltaTime) {
                if (Date.now() - this.createdAt > this.duration) {
                    this.remove();
                }
            }

            draw() {
                ctx.globalAlpha = 0.7; // ì•½ê°„ ë°˜íˆ¬ëª…
                ctx.font = `${this.size}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);
                ctx.globalAlpha = 1.0;
            }

            remove() {
                const index = gameState.effects.indexOf(this);
                if (index > -1) {
                    gameState.effects.splice(index, 1);
                }
            }
        }


        // í”Œë ˆì´ì–´ ê¸°ì§€ í´ë˜ìŠ¤ (êµ¬ ë²™ì»¤)
        class PlayerBase {
            constructor() {
                this.x = width / 2;
                this.y = height / 2;
                this.radius = 35; // ì¶©ëŒ ë°˜ê²½
                this.color = '#8B4513'; // ê°ˆìƒ‰ (ìš¸íƒ€ë¦¬ìƒ‰)
                this.maxHp = 100;
                this.hp = this.maxHp;
                this.level = 1;
                this.xp = 0;
                this.xpToNextLevel = 10;
                this.regen = 0.1; // ì´ˆë‹¹ ì²´ë ¥ 0.1 íšŒë³µ
            }

            draw() {
                ctx.fillStyle = this.color;
                const fenceWidth = 10;
                const fenceLength = 40;
                
                // ìš¸íƒ€ë¦¬ ëª¨ì–‘ ê·¸ë¦¬ê¸° (4ë°©í–¥)
                ctx.fillRect(this.x - fenceLength / 2, this.y - this.radius, fenceLength, fenceWidth);
                ctx.fillRect(this.x - fenceLength / 2, this.y + this.radius - fenceWidth, fenceLength, fenceWidth);
                ctx.fillRect(this.x - this.radius, this.y - fenceLength / 2, fenceWidth, fenceLength);
                ctx.fillRect(this.x + this.radius - fenceWidth, this.y - fenceLength / 2, fenceWidth, fenceLength);
            }

            update(deltaTime) {
                // ì²´ë ¥ ì¬ìƒ
                if (this.regen > 0 && this.hp < this.maxHp) {
                    this.hp += this.regen * (deltaTime / 1000);
                    if (this.hp > this.maxHp) this.hp = this.maxHp;
                }
                
                ui.bunkerHpFill.style.width = `${(this.hp / this.maxHp) * 100}%`;
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.hp = 0;
                    gameOver();
                }
                ui.bunkerHpFill.style.width = `${(this.hp / this.maxHp) * 100}%`;
            }

            gainXp(amount) {
                if (!gameState.isRunning) return;

                this.xp += amount;
                if (this.xp >= this.xpToNextLevel) {
                    this.levelUp();
                }
                ui.xpFill.style.width = `${(this.xp / this.xpToNextLevel) * 100}%`;
            }

            levelUp() {
                this.xp -= this.xpToNextLevel; // ë‚¨ì€ ê²½í—˜ì¹˜ ì´ì›”
                this.level++;
                this.xpToNextLevel = Math.floor(this.xpToNextLevel * 1.5); // ë‹¤ìŒ ë ˆë²¨ í•„ìš” ê²½í—˜ì¹˜ ì¦ê°€
                ui.levelText.textContent = `LV. ${this.level}`;
                
                // ë ˆë²¨ì—… ì‹œ ì²´ë ¥ 100% íšŒë³µ
                this.hp = this.maxHp; 
                
                pauseGame(true);
                gameState.isLevelUp = true;
                showLevelUpUI();
            }
        }

        // ë¬´ê¸° í´ë˜ìŠ¤ (ë§ˆë¦°, íŒŒì´ì–´ë±ƒ, íƒ±í¬, ê³ ìŠ¤íŠ¸)
        class Weapon {
            constructor(type, owner) {
                this.type = type;
                this.owner = owner;
                this.level = 1;
                this.lastShotTime = 0;
                
                // íƒ€ì…ë³„ ê¸°ë³¸ ìŠ¤íƒ¯ (ì‚¬ì •ê±°ë¦¬, ê³µì† ìˆ˜ì •)
                if (type === 'marine') {
                    this.range = 300; // ìƒí–¥
                    this.attackSpeed = 900; // ìƒí–¥
                    this.damage = 8;
                    this.projectileSpeed = 8;
                } else if (type === 'firebat') {
                    this.range = 120; // ìƒí–¥ (ì´ì œ ì´ê²Œ AOE ë²”ìœ„)
                    this.attackSpeed = 1300; // ìƒí–¥
                    this.damage = 10;
                    // projectileSpeed ì œê±°
                } else if (type === 'tank') {
                    this.range = 550; // ìƒí–¥ (ìµœì¥ ì‚¬ê±°ë¦¬)
                    this.attackSpeed = 2800; // ìƒí–¥
                    this.damage = 30; // ìŠ¤í”Œë˜ì‹œ ë°ë¯¸ì§€
                    this.aoeRadius = 70; // ìƒí–¥ (ìŠ¤í”Œë˜ì‹œ ë²”ìœ„)
                } else if (type === 'ghost') {
                    this.range = 450; // ìƒí–¥ (2ë²ˆì§¸ ì‚¬ê±°ë¦¬)
                    this.attackSpeed = 3500; // ìƒí–¥
                    this.damage = 50; // ê°•ë ¥í•œ í•œë°©
                    this.projectileSpeed = 20; // ë¹ ë¦„
                }
            }

            update(deltaTime) {
                const now = Date.now();
                if (now - this.lastShotTime > this.attackSpeed) {
                    // ì‚¬ì •ê±°ë¦¬ ë‚´ì˜ ëª¨ë“  ì ì„ ì°¾ìŒ
                    const targetsInRange = gameState.enemies.filter(enemy => {
                        const dx = enemy.x - this.owner.x;
                        const dy = enemy.y - this.owner.y;
                        return Math.sqrt(dx * dx + dy * dy) <= this.range;
                    });
                    
                    if (targetsInRange.length > 0) {
                        let target; // íƒ±í¬, ê³ ìŠ¤íŠ¸, ë§ˆë¦°ì€ íƒ€ê²Ÿì´ í•„ìš”
                        
                        if (this.type === 'firebat') {
                            // íŒŒì´ì–´ë±ƒì€ íƒ€ê²Ÿ ì—†ì´ ê·¸ëƒ¥ ë°œì‚¬
                            this.shoot(null, targetsInRange); // ë²”ìœ„ ë‚´ ëª¨ë“  ì ì„ ì „ë‹¬
                        } else {
                            // ë‚˜ë¨¸ì§€ ìœ ë‹›ë“¤
                            if (this.type === 'ghost') {
                                // ê³ ìŠ¤íŠ¸: ì²´ë ¥ì´ ê°€ì¥ ë§ì€ ì  ìš°ì„  íƒ€ê²Ÿ
                                targetsInRange.sort((a, b) => b.hp - a.hp);
                                target = targetsInRange[0];
                            } else {
                                // ë§ˆë¦°, íƒ±í¬: ì‚¬ì •ê±°ë¦¬ ë‚´ ëœë¤ íƒ€ê²Ÿ (ì˜¤ë²„í‚¬ ë°©ì§€)
                                target = targetsInRange[Math.floor(Math.random() * targetsInRange.length)];
                            }
                            this.shoot(target);
                        }
                        this.lastShotTime = now;
                    }
                }
            }

            shoot(target, targetsInRange = []) { // íŒŒì´ì–´ë±ƒì„ ìœ„í•´ targetsInRange ì¶”ê°€
                if (this.type === 'tank') {
                    // íƒ±í¬: ì¦‰ë°œ í­ë°œ ë° ë²”ìœ„ ë°ë¯¸ì§€
                    gameState.effects.push(new Effect(target.x, target.y, 'ğŸ’¥', 60)); // í­ë°œ í¬ê¸° 60
                    
                    // ë²”ìœ„ ë°ë¯¸ì§€
                    gameState.enemies.forEach(otherEnemy => {
                        const dxSplash = target.x - otherEnemy.x;
                        const dySplash = target.y - otherEnemy.y;
                        if (Math.sqrt(dxSplash * dxSplash + dySplash * dySplash) < this.aoeRadius) {
                            otherEnemy.takeDamage(this.damage); // 100% ë²”ìœ„ ë°ë¯¸ì§€
                        }
                    });

                } else if (this.type === 'firebat') {
                    // íŒŒì´ì–´ë±ƒ: ì¦‰ë°œ ê·¼ê±°ë¦¬ ë²”ìœ„ ë°ë¯¸ì§€ (íˆ¬ì‚¬ì²´ ì—†ìŒ)
                    // targetsInRange (ì´ë¯¸ ì‚¬ì •ê±°ë¦¬ ë‚´ì— ìˆëŠ” ì ë“¤)ì„ ë°”ë¡œ ê³µê²©
                    gameState.effects.push(new Effect(this.owner.x, this.owner.y, 'ğŸ”¥', this.range * 2, 200)); // í™”ì—¼ í¬ê¸° = ì‚¬ê±°ë¦¬*2, 0.2ì´ˆê°„ ì§€ì†
                    targetsInRange.forEach(enemy => {
                        enemy.takeDamage(this.damage);
                    });

                } else {
                    // ë§ˆë¦°, ê³ ìŠ¤íŠ¸: íˆ¬ì‚¬ì²´ ë°œì‚¬
                    const dx = target.x - this.owner.x;
                    const dy = target.y - this.owner.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    
                    const velocityX = (dx / dist) * this.projectileSpeed;
                    const velocityY = (dy / dist) * this.projectileSpeed;

                    gameState.projectiles.push(new Projectile(
                        this.owner.x,
                        this.owner.y,
                        velocityX,
                        velocityY,
                        this.damage,
                        this.type
                    ));
                }
            }

            applyStats() {
                // ë ˆë²¨ì—… ìŠ¤íƒ¯ ì ìš© (ê³µì† ìƒí–¥ ë°˜ì˜)
                const levelBonus = this.level - 1;
                if (this.type === 'marine') {
                    this.damage = 8 + levelBonus * 2;
                    this.attackSpeed = Math.max(150, 900 - levelBonus * 60); // ê³µì† ì—…ê·¸ë ˆì´ë“œ ìƒí–¥
                } else if (this.type === 'firebat') {
                    this.damage = 10 + levelBonus * 3;
                    this.range = 120 + levelBonus * 10; // ë²”ìœ„ ì¦ê°€
                    this.attackSpeed = Math.max(300, 1300 - levelBonus * 80);
                } else if (this.type === 'tank') {
                    this.damage = 30 + levelBonus * 5;
                    this.attackSpeed = Math.max(800, 2800 - levelBonus * 150);
                    this.aoeRadius = 70 + levelBonus * 10; // ë²”ìœ„ ì¦ê°€ ìƒí–¥
                } else if (type === 'ghost') {
                    this.damage = 50 + levelBonus * 10;
                    this.attackSpeed = Math.max(1000, 3500 - levelBonus * 250);
                }
            }
        }

        // ì´ì•Œ í´ë˜ìŠ¤ (íŒŒì´ì–´ë±ƒ ì œê±°)
        class Projectile {
            constructor(x, y, vx, vy, damage, type) {
                this.x = x;
                this.y = y;
                this.vx = vx;
                this.vy = vy;
                this.damage = damage;
                this.type = type;
                this.pierce = false; // ê´€í†µ ì—†ìŒ
                
                if (type === 'marine') {
                    this.radius = 3;
                    this.color = '#FFFF00'; // ë…¸ë‘
                } else if (type === 'ghost') {
                    this.radius = 4;
                    this.color = '#00BFFF'; // í•˜ëŠ˜ìƒ‰
                }
            }

            update(deltaTime) {
                this.x += this.vx;
                this.y += this.vy;

                // í™”ë©´ ë°–ìœ¼ë¡œ ë‚˜ê°€ë©´ ì œê±°
                if (this.x < 0 || this.x > width || this.y < 0 || this.y > height) {
                    this.remove();
                    return; // í•¨ìˆ˜ ì¢…ë£Œ
                }

                // ì¶©ëŒ ê°ì§€
                for (let i = gameState.enemies.length - 1; i >= 0; i--) {
                    const enemy = gameState.enemies[i];
                    if (!enemy) continue; // ì˜ˆì™¸ ì²˜ë¦¬

                    const dx = this.x - enemy.x;
                    const dy = this.y - enemy.y;
                    const dist = Math.sqrt(dx * dx + dy * dy);

                    if (dist < this.radius + enemy.radius) {
                        // ë©”ì¸ íƒ€ê²Ÿ ë°ë¯¸ì§€
                        enemy.takeDamage(this.damage);
                        this.remove(); // ê´€í†µì´ ì•„ë‹ˆë¯€ë¡œ ì´ì•Œ ì œê±°
                        break; // ë°˜ë³µ ì¤‘ì§€
                    }
                }
            }

            draw() {
                // ì¼ë°˜ ì›
                ctx.fillStyle = this.color;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2);
                ctx.fill();
            }

            remove() {
                const index = gameState.projectiles.indexOf(this);
                if (index > -1) {
                    gameState.projectiles.splice(index, 1);
                }
            }
        }

        // ì  í´ë˜ìŠ¤
        class Enemy {
            constructor(type) {
                this.type = type;
                this.isAttacking = false;
                this.attackCooldown = 1000; // 1ì´ˆë§ˆë‹¤ ê³µê²©
                this.lastAttackTime = 0;
                const diff = gameState.difficultyMultiplier; // ë‚œì´ë„ ë°°ìœ¨ ì ìš©

                // ìŠ¤í° ìœ„ì¹˜ (í™”ë©´ ê°€ì¥ìë¦¬)
                const spawnSide = Math.floor(Math.random() * 4);
                if (spawnSide === 0) { this.x = Math.random() * width; this.y = -20; }
                else if (spawnSide === 1) { this.x = width + 20; this.y = Math.random() * height; }
                else if (spawnSide === 2) { this.x = Math.random() * width; this.y = height + 20; }
                else { this.x = -20; this.y = Math.random() * height; }

                // íƒ€ì…ë³„ ìŠ¤íƒ¯ (ë‚œì´ë„ ë°°ìœ¨ ì ìš©)
                if (type === 'zergling') {
                    this.radius = 12;
                    this.speed = 1.5 + Math.random() * 0.5;
                    this.maxHp = Math.ceil(5 * diff);
                    this.damage = Math.ceil(1 * diff);
                    this.xpValue = Math.max(1, Math.ceil(1 / (diff * 0.5 + 0.5))); // ë‚œì´ë„ ë†’ì„ìˆ˜ë¡ ê²½í—˜ì¹˜ ê°ì†Œ (ì¡°ì •)
                    this.emoji = 'ğŸ›';
                } else if (type === 'hydralisk') {
                    this.radius = 16;
                    this.speed = 1.0 + Math.random() * 0.3;
                    this.maxHp = Math.ceil(15 * diff);
                    this.damage = Math.ceil(3 * diff);
                    this.xpValue = Math.max(1, Math.ceil(3 / (diff * 0.5 + 0.5)));
                    this.emoji = 'ğŸ';
                } else if (type === 'muta') {
                    this.radius = 10;
                    this.speed = 2.5 + Math.random() * 0.5; // ë¹ ë¦„
                    this.maxHp = Math.ceil(4 * diff);
                    this.damage = Math.ceil(1 * diff);
                    this.xpValue = Math.max(1, Math.ceil(1 / (diff * 0.5 + 0.5)));
                    this.emoji = 'ğŸ¦‡';
                } else if (type === 'ultra') {
                    this.radius = 30; // í¼
                    this.speed = 0.8 + Math.random() * 0.2; // ëŠë¦¼
                    this.maxHp = Math.ceil(100 * diff);
                    this.damage = Math.ceil(10 * diff);
                    this.xpValue = Math.max(5, Math.ceil(20 / (diff * 0.5 + 0.5)));
                    this.emoji = 'ğŸ¦–';
                }
                this.hp = this.maxHp;
            }

            update(deltaTime) {
                const playerBase = gameState.playerBase;
                const dx = playerBase.x - this.x;
                const dy = playerBase.y - this.y;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                // ê¸°ì§€ì™€ ë‹¿ì•˜ëŠ”ì§€ í™•ì¸
                if (dist < this.radius + playerBase.radius) {
                    this.isAttacking = true;
                } else {
                    this.isAttacking = false;
                }

                if (this.isAttacking) {
                    // ê³µê²©
                    const now = Date.now();
                    if (now - this.lastAttackTime > this.attackCooldown) {
                        playerBase.takeDamage(this.damage);
                        this.lastAttackTime = now;
                    }
                } else {
                    // ì´ë™
                    this.x += (dx / dist) * this.speed;
                    this.y += (dy / dist) * this.speed;
                }
            }

            draw() {
                // ì´ëª¨ì§€ ê·¸ë¦¬ê¸°
                ctx.font = `${this.radius * 2}px sans-serif`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(this.emoji, this.x, this.y);

                // ì²´ë ¥ë°”
                if (this.hp < this.maxHp) {
                    const hpBarWidth = this.radius * 2;
                    const hpBarHeight = 4;
                    const yOffset = this.y + this.radius + 5;
                    
                    ctx.fillStyle = '#FF0000'; // ë¹¨ê°„ìƒ‰ (ë°°ê²½)
                    ctx.fillRect(this.x - hpBarWidth / 2, yOffset, hpBarWidth, hpBarHeight);
                    
                    ctx.fillStyle = '#00FF00'; // ë…¹ìƒ‰ (í˜„ì¬ ì²´ë ¥)
                    ctx.fillRect(this.x - hpBarWidth / 2, yOffset, hpBarWidth * (this.hp / this.maxHp), hpBarHeight);
                }
            }

            takeDamage(amount) {
                this.hp -= amount;
                if (this.hp <= 0) {
                    this.die();
                }
            }

            die() {
                // ì  ë°°ì—´ì—ì„œ ì œê±°
                const index = gameState.enemies.indexOf(this);
                if (index > -1) {
                    gameState.enemies.splice(index, 1);
                }
                gameState.playerBase.gainXp(this.xpValue); // ì¦‰ì‹œ ê²½í—˜ì¹˜ íšë“

                gameState.killCount++;
                ui.killCount.textContent = `Kills: ${gameState.killCount}`;
            }
        }

        // ì—…ê·¸ë ˆì´ë“œ ëª©ë¡
        const allUpgrades = [
            { id: 'add_marine', title: 'ë§ˆë¦° ì¶©ì›', desc: 'ìƒˆë¡œìš´ ë§ˆë¦°ì„ ê¸°ì§€ì— ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 6ê¸°)' },
            { id: 'add_firebat', title: 'íŒŒì´ì–´ë±ƒ ì¶©ì›', desc: 'ê·¼ê±°ë¦¬ ê´‘ì—­ ê³µê²© íŒŒì´ì–´ë±ƒì„ ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 2ê¸°)' },
            { id: 'add_tank', title: 'ì‹œì¦ˆ íƒ±í¬ ì¶”ê°€', desc: 'ê°•ë ¥í•œ ë²”ìœ„ í”¼í•´ë¥¼ ì£¼ëŠ” íƒ±í¬ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 2ê¸°)' },
            { id: 'add_ghost', title: 'ê³ ìŠ¤íŠ¸ ì¶”ê°€', desc: 'ê°•ë ¥í•œ ì €ê²© ìœ ë‹› ê³ ìŠ¤íŠ¸ë¥¼ ì¶”ê°€í•©ë‹ˆë‹¤. (ìµœëŒ€ 2ê¸°)' },
            { id: 'upgrade_marine', title: 'ë§ˆë¦° ê³µê²©ë ¥/ì—°ì‚¬ë ¥ ì¦ê°€', desc: 'ëª¨ë“  ë§ˆë¦°ì˜ ê³µê²©ë ¥ê³¼ ê³µê²© ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'upgrade_firebat', title: 'íŒŒì´ì–´ë±ƒ í™”ì—¼ ê°•í™”', desc: 'ëª¨ë“  íŒŒì´ì–´ë±ƒì˜ ê³µê²©ë ¥ê³¼ ë²”ìœ„, ì—°ì‚¬ë ¥ì´ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'upgrade_tank', title: 'íƒ±í¬ í¬íƒ„ ê°•í™”', desc: 'ëª¨ë“  íƒ±í¬ì˜ ê³µê²©ë ¥ê³¼ ê³µê²© ì†ë„, ë²”ìœ„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'upgrade_ghost', title: 'ê³ ìŠ¤íŠ¸ ì €ê²©ì´ ê°•í™”', desc: 'ëª¨ë“  ê³ ìŠ¤íŠ¸ì˜ ê³µê²©ë ¥ê³¼ ì¡°ì¤€ ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'bunker_max_hp', title: 'ê¸°ì§€ ìµœëŒ€ ì²´ë ¥ ì¦ê°€', desc: 'ê¸°ì§€ì˜ ìµœëŒ€ ì²´ë ¥ì´ 25 ì¦ê°€í•©ë‹ˆë‹¤.' },
            { id: 'bunker_regen', title: 'ê¸°ì§€ ìë™ ìˆ˜ë¦¬', desc: 'ê¸°ì§€ì˜ ì´ˆë‹¹ ì²´ë ¥ ì¬ìƒ ì†ë„ê°€ ì¦ê°€í•©ë‹ˆë‹¤.' },
        ];

        // í˜„ì¬ ê°€ëŠ¥í•œ ì—…ê·¸ë ˆì´ë“œ ëª©ë¡ í•„í„°ë§
        function getAvailableUpgrades() {
            const available = [];
            const marineCount = gameState.weapons.filter(w => w.type === 'marine').length;
            const firebatCount = gameState.weapons.filter(w => w.type === 'firebat').length;
            const tankCount = gameState.weapons.filter(w => w.type === 'tank').length;
            const ghostCount = gameState.weapons.filter(w => w.type === 'ghost').length;

            allUpgrades.forEach(upg => {
                if (upg.id === 'add_marine' && marineCount < 6) available.push(upg);
                else if (upg.id === 'add_firebat' && firebatCount < 2) available.push(upg);
                else if (upg.id === 'add_tank' && tankCount < 2) available.push(upg);
                else if (upg.id === 'add_ghost' && ghostCount < 2) available.push(upg);
                else if (upg.id === 'upgrade_marine' && marineCount > 0) available.push(upg);
                else if (upg.id === 'upgrade_firebat' && firebatCount > 0) available.push(upg);
                else if (upg.id === 'upgrade_tank' && tankCount > 0) available.push(upg);
                else if (upg.id === 'upgrade_ghost' && ghostCount > 0) available.push(upg);
                else if (upg.id === 'bunker_max_hp' || upg.id === 'bunker_regen') available.push(upg);
            });
            
            // 3ê°œ ëœë¤ ì„ íƒ (ì¤‘ë³µ ì—†ì´)
            const shuffled = available.sort(() => 0.5 - Math.random());
            return shuffled.slice(0, 3);
        }

        // ë ˆë²¨ì—… UI í‘œì‹œ
        function showLevelUpUI() {
            ui.upgradeContainer.innerHTML = ''; // ì´ˆê¸°í™”
            const options = getAvailableUpgrades();
            
            options.forEach(option => {
                const div = document.createElement('div');
                div.className = 'upgrade-option';
                div.innerHTML = `<h3>${option.title}</h3><p>${option.desc}</p>`;
                div.onclick = () => selectUpgrade(option.id);
                ui.upgradeContainer.appendChild(div);
            });

            ui.levelUpOverlay.style.display = 'flex';
        }

        // ì—…ê·¸ë ˆì´ë“œ ì„ íƒ
        function selectUpgrade(id) {
            const playerBase = gameState.playerBase;
            
            switch (id) {
                case 'add_marine':
                    gameState.weapons.push(new Weapon('marine', playerBase));
                    break;
                case 'add_firebat':
                    gameState.weapons.push(new Weapon('firebat', playerBase));
                    break;
                case 'add_tank':
                    gameState.weapons.push(new Weapon('tank', playerBase));
                    break;
                case 'add_ghost':
                    gameState.weapons.push(new Weapon('ghost', playerBase));
                    break;
                
                case 'upgrade_marine':
                    gameState.weapons.filter(w => w.type === 'marine').forEach(w => { w.level++; w.applyStats(); });
                    break;
                case 'upgrade_firebat':
                     gameState.weapons.filter(w => w.type === 'firebat').forEach(w => { w.level++; w.applyStats(); });
                    break;
                case 'upgrade_tank':
                     gameState.weapons.filter(w => w.type === 'tank').forEach(w => { w.level++; w.applyStats(); });
                    break;
                case 'upgrade_ghost':
                     gameState.weapons.filter(w => w.type === 'ghost').forEach(w => { w.level++; w.applyStats(); });
                    break;

                case 'bunker_max_hp':
                    playerBase.maxHp += 25;
                    playerBase.hp += 25; // í˜„ì¬ ì²´ë ¥ë„ ì˜¬ë ¤ì¤Œ
                    break;
                case 'bunker_regen':
                    playerBase.regen += 0.2;
                    break;
            }

            updateUnitCountUI(); // ìœ ë‹› ìˆ˜ UI ì¦‰ì‹œ ì—…ë°ì´íŠ¸
            ui.levelUpOverlay.style.display = 'none';
            gameState.isLevelUp = false;
            pauseGame(false); // ê²Œì„ ì¬ê°œ
        }
        
        // ë³´ìœ  ìœ ë‹› ìˆ˜ UI ì—…ë°ì´íŠ¸
        function updateUnitCountUI() {
            const marineCount = gameState.weapons.filter(w => w.type === 'marine').length;
            const firebatCount = gameState.weapons.filter(w => w.type === 'firebat').length;
            const tankCount = gameState.weapons.filter(w => w.type === 'tank').length;
            const ghostCount = gameState.weapons.filter(w => w.type === 'ghost').length;

            ui.marineCount.textContent = `ğŸ§‘â€ğŸš€ ${marineCount}`;
            ui.firebatCount.textContent = `ğŸ”¥ ${firebatCount}`;
            ui.tankCount.textContent = `ğŸ›¡ï¸ ${tankCount}`; // íƒ±í¬ ì•„ì´ì½˜
            ui.ghostCount.textContent = `ğŸ‘» ${ghostCount}`;
        }
        
        // ëª¬ìŠ¤í„° ì •ë³´ UI ì—…ë°ì´íŠ¸
        function updateMonsterInfoUI() {
            const time = gameState.elapsedTime;
            let info = "ë“±ì¥: ğŸ›";
            
            if (time > 30000) info += " ğŸ"; // 30ì´ˆ
            if (time > 60000) info += " ğŸ¦‡"; // 1ë¶„
            if (time > 180000) info += " ğŸ¦– (BOSS)"; // 3ë¶„

            if (info !== gameState.lastMonsterInfo) {
                ui.monsterInfo.textContent = info;
                gameState.lastMonsterInfo = info;
            }
        }


        // ê²Œì„ ìŠ¤í° ë¡œì§
        function handleSpawning(deltaTime) {
            gameState.spawnTimer += deltaTime;
            // ë‚œì´ë„ ë°°ìœ¨ì— ë”°ë¼ ìŠ¤í° ê°„ê²© ì¡°ì ˆ
            const currentSpawnInterval = gameState.spawnInterval / gameState.difficultyMultiplier;

            if (gameState.spawnTimer > currentSpawnInterval) {
                gameState.spawnTimer = 0;
                
                // ë‚œì´ë„ ì¡°ì ˆ (ì‹œê°„ì´ ì§€ë‚ ìˆ˜ë¡ ìŠ¤í° ê°„ê²© ì§§ì•„ì§)
                gameState.spawnInterval = Math.max(300, 2500 - gameState.elapsedTime / 1000 * 10); // 2500 ê¸°ì¤€ìœ¼ë¡œ
                
                let enemyType = 'zergling'; // ê¸°ë³¸
                const time = gameState.elapsedTime;
                
                if (time > 180000 && Math.random() < 0.05) { // 3ë¶„ í›„ ìš¸íŠ¸ë¼
                    enemyType = 'ultra';
                } else if (time > 60000 && Math.random() < 0.2) { // 1ë¶„ í›„ ë®¤íƒˆ
                    enemyType = 'muta';
                } else if (time > 30000 && Math.random() < 0.3) { // 30ì´ˆ í›„ íˆë“œë¼
                    enemyType = 'hydralisk';
                }
                
                gameState.enemies.push(new Enemy(enemyType));
            }
        }

        // ê²Œì„ ì‹œì‘
        function startGame(difficulty) {
            resizeCanvas(); // ì‹œì‘í•  ë•Œ ìº”ë²„ìŠ¤ í¬ê¸° ë§ì¶”ê¸°
            
            const playerBase = new PlayerBase();
            
            gameState = {
                isRunning: true,
                isPaused: false,
                isLevelUp: false,
                startTime: Date.now(),
                elapsedTime: 0,
                lastTime: Date.now(),
                killCount: 0,
                playerBase: playerBase,
                enemies: [],
                projectiles: [],
                effects: [], // íš¨ê³¼ ë°°ì—´ ì´ˆê¸°í™”
                weapons: [new Weapon('marine', playerBase)], // ê¸°ë³¸ ë§ˆë¦° 1ê¸°
                spawnTimer: 0,
                spawnInterval: 2500, // ê¸°ë³¸ ìŠ¤í° ê°„ê²© (ìƒí–¥)
                difficultyMultiplier: difficulty, // ì„ íƒëœ ë‚œì´ë„ ë°°ìœ¨ ì„¤ì •
                lastMonsterInfo: "" // ëª¬ìŠ¤í„° ì •ë³´ ìºì‹œ ì´ˆê¸°í™”
            };
            
            // UI ì´ˆê¸°í™”
            ui.startOverlay.style.display = 'none';
            ui.gameOverOverlay.style.display = 'none';
            ui.levelText.textContent = 'LV. 1';
            ui.killCount.textContent = 'Kills: 0';
            ui.timer.textContent = '00:00';
            ui.xpFill.style.width = '0%';
            ui.bunkerHpFill.style.width = '100%';
            ui.monsterInfo.textContent = 'ë“±ì¥: ğŸ›'; // ëª¬ìŠ¤í„° ì •ë³´ ì´ˆê¸°í™”
            updateUnitCountUI(); // ìœ ë‹› ìˆ˜ ì´ˆê¸°í™”

            requestAnimationFrame(gameLoop);
        }

        // ê²Œì„ ì˜¤ë²„
        function gameOver() {
            gameState.isRunning = false;
            document.getElementById('game-over-stats').textContent = `ìµœì¢… ìƒì¡´ ì‹œê°„: ${formatTime(gameState.elapsedTime)} | ìµœì¢… í‚¬ ìˆ˜: ${gameState.killCount}`;
            ui.gameOverOverlay.style.display = 'flex';
        }
        
        // ë‹¤ì‹œ ì‹œì‘ (ì‹œì‘ í™”ë©´ìœ¼ë¡œ)
        function restartGame() {
            ui.gameOverOverlay.style.display = 'none';
            ui.startOverlay.style.display = 'flex';
        }

        // ê²Œì„ ì¼ì‹œì •ì§€/ì¬ê°œ
        function pauseGame(isPaused) {
            gameState.isPaused = isPaused;
            if (!isPaused) {
                gameState.lastTime = Date.now();
                if (!gameState.isLevelUp) {
                    requestAnimationFrame(gameLoop);
                }
            }
        }

        // ë©”ì¸ ê²Œì„ ë£¨í”„
        function gameLoop() {
            if (!gameState.isRunning || gameState.isPaused || gameState.isLevelUp) {
                return;
            }

            const now = Date.now();
            const deltaTime = now - gameState.lastTime;
            gameState.lastTime = now;
            
            // í”„ë ˆì„ ë“œë ë°©ì§€ (ìµœëŒ€ 100msê¹Œì§€ë§Œ ì¸ì •)
            const effectiveDeltaTime = Math.min(deltaTime, 100); 

            gameState.elapsedTime += effectiveDeltaTime;
            ui.timer.textContent = formatTime(gameState.elapsedTime);

            // ì—…ë°ì´íŠ¸
            gameState.playerBase.update(effectiveDeltaTime);
            gameState.weapons.forEach(w => w.update(effectiveDeltaTime));
            [...gameState.enemies].forEach(enemy => enemy.update(effectiveDeltaTime));
            [...gameState.projectiles].forEach(p => p.update(effectiveDeltaTime));
            [...gameState.effects].forEach(e => e.update(effectiveDeltaTime)); // íš¨ê³¼ ì—…ë°ì´íŠ¸
            
            // UI ì—…ë°ì´íŠ¸
            updateMonsterInfoUI();

            // ìŠ¤í¬ë‹
            handleSpawning(effectiveDeltaTime);

            // ê·¸ë¦¬ê¸°
            ctx.clearRect(0, 0, width, height);
            gameState.playerBase.draw();
            gameState.enemies.forEach(enemy => enemy.draw());
            gameState.projectiles.forEach(p => p.draw());
            gameState.effects.forEach(e => e.draw()); // íš¨ê³¼ ê·¸ë¦¬ê¸°

            requestAnimationFrame(gameLoop);
        }

        // ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        window.addEventListener('resize', resizeCanvas);
        
        // ë‚œì´ë„ ë²„íŠ¼ ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ
        ui.difficultyButtons.forEach(button => {
            button.addEventListener('click', () => {
                const difficulty = parseFloat(button.getAttribute('data-diff'));
                startGame(difficulty);
            });
        });
        
        ui.restartButton.addEventListener('click', restartGame); // ë‹¤ì‹œ ì‹œì‘ ë²„íŠ¼ ìˆ˜ì •

        // ì´ˆê¸° ìº”ë²„ìŠ¤ í¬ê¸° ì„¤ì •
        resizeCanvas();
        
    </script>

</body>
</html>
